{"version":3,"file":"npm.fast-png.a7cba17ee621cb2ad512.chunk.js","mappings":"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","sources":["webpack://tweb/./node_modules/fast-png/lib-esm/common.js","webpack://tweb/./node_modules/fast-png/lib-esm/internalTypes.js","webpack://tweb/./node_modules/fast-png/lib-esm/PngDecoder.js","webpack://tweb/./node_modules/fast-png/lib-esm/PngEncoder.js","webpack://tweb/./node_modules/fast-png/lib-esm/types.js","webpack://tweb/./node_modules/fast-png/lib-esm/index.js"],"sourcesContent":["export const pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];\nconst crcTable = [];\nfor (let n = 0; n < 256; n++) {\n    let c = n;\n    for (let k = 0; k < 8; k++) {\n        if (c & 1) {\n            c = 0xedb88320 ^ (c >>> 1);\n        }\n        else {\n            c = c >>> 1;\n        }\n    }\n    crcTable[n] = c;\n}\nconst initialCrc = 0xffffffff;\nfunction updateCrc(currentCrc, data, length) {\n    let c = currentCrc;\n    for (let n = 0; n < length; n++) {\n        c = crcTable[(c ^ data[n]) & 0xff] ^ (c >>> 8);\n    }\n    return c;\n}\nexport function crc(data, length) {\n    return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;\n}\n//# sourceMappingURL=common.js.map","export var ColorType;\n(function (ColorType) {\n    ColorType[ColorType[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n    ColorType[ColorType[\"GREYSCALE\"] = 0] = \"GREYSCALE\";\n    ColorType[ColorType[\"TRUECOLOUR\"] = 2] = \"TRUECOLOUR\";\n    ColorType[ColorType[\"INDEXED_COLOUR\"] = 3] = \"INDEXED_COLOUR\";\n    ColorType[ColorType[\"GREYSCALE_ALPHA\"] = 4] = \"GREYSCALE_ALPHA\";\n    ColorType[ColorType[\"TRUECOLOUR_ALPHA\"] = 6] = \"TRUECOLOUR_ALPHA\";\n})(ColorType || (ColorType = {}));\nexport var CompressionMethod;\n(function (CompressionMethod) {\n    CompressionMethod[CompressionMethod[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n    CompressionMethod[CompressionMethod[\"DEFLATE\"] = 0] = \"DEFLATE\";\n})(CompressionMethod || (CompressionMethod = {}));\nexport var FilterMethod;\n(function (FilterMethod) {\n    FilterMethod[FilterMethod[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n    FilterMethod[FilterMethod[\"ADAPTIVE\"] = 0] = \"ADAPTIVE\";\n})(FilterMethod || (FilterMethod = {}));\nexport var InterlaceMethod;\n(function (InterlaceMethod) {\n    InterlaceMethod[InterlaceMethod[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n    InterlaceMethod[InterlaceMethod[\"NO_INTERLACE\"] = 0] = \"NO_INTERLACE\";\n    InterlaceMethod[InterlaceMethod[\"ADAM7\"] = 1] = \"ADAM7\";\n})(InterlaceMethod || (InterlaceMethod = {}));\n//# sourceMappingURL=internalTypes.js.map","import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { pngSignature, crc } from './common';\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod, } from './internalTypes';\nconst empty = new Uint8Array(0);\nconst NULL = '\\0';\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\nexport default class PngDecoder extends IOBuffer {\n    constructor(data, options = {}) {\n        super(data);\n        const { checkCrc = false } = options;\n        this._checkCrc = checkCrc;\n        this._inflator = new Inflator();\n        this._png = {\n            width: -1,\n            height: -1,\n            channels: -1,\n            data: new Uint8Array(0),\n            depth: 1,\n            text: {},\n        };\n        this._end = false;\n        this._hasPalette = false;\n        this._palette = [];\n        this._compressionMethod = CompressionMethod.UNKNOWN;\n        this._filterMethod = FilterMethod.UNKNOWN;\n        this._interlaceMethod = InterlaceMethod.UNKNOWN;\n        this._colorType = -1;\n        // PNG is always big endian\n        // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n        this.setBigEndian();\n    }\n    decode() {\n        this.decodeSignature();\n        while (!this._end) {\n            this.decodeChunk();\n        }\n        this.decodeImage();\n        return this._png;\n    }\n    // https://www.w3.org/TR/PNG/#5PNG-file-signature\n    decodeSignature() {\n        for (let i = 0; i < pngSignature.length; i++) {\n            if (this.readUint8() !== pngSignature[i]) {\n                throw new Error(`wrong PNG signature. Byte at ${i} should be ${pngSignature[i]}.`);\n            }\n        }\n    }\n    // https://www.w3.org/TR/PNG/#5Chunk-layout\n    decodeChunk() {\n        const length = this.readUint32();\n        const type = this.readChars(4);\n        const offset = this.offset;\n        switch (type) {\n            // 11.2 Critical chunks\n            case 'IHDR': // 11.2.2 IHDR Image header\n                this.decodeIHDR();\n                break;\n            case 'PLTE': // 11.2.3 PLTE Palette\n                this.decodePLTE(length);\n                break;\n            case 'IDAT': // 11.2.4 IDAT Image data\n                this.decodeIDAT(length);\n                break;\n            case 'IEND': // 11.2.5 IEND Image trailer\n                this._end = true;\n                break;\n            // 11.3 Ancillary chunks\n            case 'tRNS': // 11.3.2.1 tRNS Transparency\n                this.decodetRNS(length);\n                break;\n            case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile\n                this.decodeiCCP(length);\n                break;\n            case 'tEXt': // 11.3.4.3 tEXt Textual data\n                this.decodetEXt(length);\n                break;\n            case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\n                this.decodepHYs();\n                break;\n            default:\n                this.skip(length);\n                break;\n        }\n        if (this.offset - offset !== length) {\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\n        }\n        if (this._checkCrc) {\n            const expectedCrc = this.readUint32();\n            const crcLength = length + 4; // includes type\n            const actualCrc = crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\n            if (actualCrc !== expectedCrc) {\n                throw new Error(`CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`);\n            }\n        }\n        else {\n            this.skip(4);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    decodeIHDR() {\n        const image = this._png;\n        image.width = this.readUint32();\n        image.height = this.readUint32();\n        image.depth = checkBitDepth(this.readUint8());\n        const colorType = this.readUint8();\n        this._colorType = colorType;\n        let channels;\n        switch (colorType) {\n            case ColorType.GREYSCALE:\n                channels = 1;\n                break;\n            case ColorType.TRUECOLOUR:\n                channels = 3;\n                break;\n            case ColorType.INDEXED_COLOUR:\n                channels = 1;\n                break;\n            case ColorType.GREYSCALE_ALPHA:\n                channels = 2;\n                break;\n            case ColorType.TRUECOLOUR_ALPHA:\n                channels = 4;\n                break;\n            default:\n                throw new Error(`Unknown color type: ${colorType}`);\n        }\n        this._png.channels = channels;\n        this._compressionMethod = this.readUint8();\n        if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n        }\n        this._filterMethod = this.readUint8();\n        this._interlaceMethod = this.readUint8();\n    }\n    // https://www.w3.org/TR/PNG/#11PLTE\n    decodePLTE(length) {\n        if (length % 3 !== 0) {\n            throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n        }\n        const l = length / 3;\n        this._hasPalette = true;\n        const palette = [];\n        this._palette = palette;\n        for (let i = 0; i < l; i++) {\n            palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    decodeIDAT(length) {\n        this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, length));\n        this.skip(length);\n    }\n    // https://www.w3.org/TR/PNG/#11tRNS\n    decodetRNS(length) {\n        // TODO: support other color types.\n        if (this._colorType === 3) {\n            if (length > this._palette.length) {\n                throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n            }\n            let i = 0;\n            for (; i < length; i++) {\n                const alpha = this.readByte();\n                this._palette[i].push(alpha);\n            }\n            for (; i < this._palette.length; i++) {\n                this._palette[i].push(255);\n            }\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11iCCP\n    decodeiCCP(length) {\n        let name = '';\n        let char;\n        while ((char = this.readChar()) !== NULL) {\n            name += char;\n        }\n        const compressionMethod = this.readUint8();\n        if (compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n        }\n        const compressedProfile = this.readBytes(length - name.length - 2);\n        this._png.iccEmbeddedProfile = {\n            name: name,\n            profile: inflate(compressedProfile),\n        };\n    }\n    // https://www.w3.org/TR/PNG/#11tEXt\n    decodetEXt(length) {\n        let keyword = '';\n        let char;\n        while ((char = this.readChar()) !== NULL) {\n            keyword += char;\n        }\n        this._png.text[keyword] = this.readChars(length - keyword.length - 1);\n    }\n    // https://www.w3.org/TR/PNG/#11pHYs\n    decodepHYs() {\n        const ppuX = this.readUint32();\n        const ppuY = this.readUint32();\n        const unitSpecifier = this.readByte();\n        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };\n    }\n    decodeImage() {\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        const data = this._inflator.result;\n        if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n            throw new Error(`Filter method ${this._filterMethod} not supported`);\n        }\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n            this.decodeInterlaceNull(data);\n        }\n        else {\n            throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n        }\n    }\n    decodeInterlaceNull(data) {\n        const height = this._png.height;\n        const bytesPerPixel = (this._png.channels * this._png.depth) / 8;\n        const bytesPerLine = this._png.width * bytesPerPixel;\n        const newData = new Uint8Array(this._png.height * bytesPerLine);\n        let prevLine = empty;\n        let offset = 0;\n        let currentLine;\n        let newLine;\n        for (let i = 0; i < height; i++) {\n            currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);\n            newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);\n            switch (data[offset]) {\n                case 0:\n                    unfilterNone(currentLine, newLine, bytesPerLine);\n                    break;\n                case 1:\n                    unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);\n                    break;\n                case 2:\n                    unfilterUp(currentLine, newLine, prevLine, bytesPerLine);\n                    break;\n                case 3:\n                    unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n                    break;\n                case 4:\n                    unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n                    break;\n                default:\n                    throw new Error(`Unsupported filter: ${data[offset]}`);\n            }\n            prevLine = newLine;\n            offset += bytesPerLine + 1;\n        }\n        if (this._hasPalette) {\n            this._png.palette = this._palette;\n        }\n        if (this._png.depth === 16) {\n            const uint16Data = new Uint16Array(newData.buffer);\n            if (osIsLittleEndian) {\n                for (let k = 0; k < uint16Data.length; k++) {\n                    // PNG is always big endian. Swap the bytes.\n                    uint16Data[k] = swap16(uint16Data[k]);\n                }\n            }\n            this._png.data = uint16Data;\n        }\n        else {\n            this._png.data = newData;\n        }\n    }\n}\nfunction unfilterNone(currentLine, newLine, bytesPerLine) {\n    for (let i = 0; i < bytesPerLine; i++) {\n        newLine[i] = currentLine[i];\n    }\n}\nfunction unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    for (; i < bytesPerPixel; i++) {\n        // just copy first bytes\n        newLine[i] = currentLine[i];\n    }\n    for (; i < bytesPerLine; i++) {\n        newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n    }\n}\nfunction unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        // just copy bytes for first line\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = currentLine[i];\n        }\n    }\n    else {\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n        }\n    }\n}\nfunction unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = currentLine[i];\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + (newLine[i - bytesPerPixel] >> 1)) & 0xff;\n        }\n    }\n    else {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = (currentLine[i] + (prevLine[i] >> 1)) & 0xff;\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] =\n                (currentLine[i] + ((newLine[i - bytesPerPixel] + prevLine[i]) >> 1)) &\n                    0xff;\n        }\n    }\n}\nfunction unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = currentLine[i];\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n        }\n    }\n    else {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] =\n                (currentLine[i] +\n                    paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel])) &\n                    0xff;\n        }\n    }\n}\nfunction paethPredictor(a, b, c) {\n    const p = a + b - c;\n    const pa = Math.abs(p - a);\n    const pb = Math.abs(p - b);\n    const pc = Math.abs(p - c);\n    if (pa <= pb && pa <= pc)\n        return a;\n    else if (pb <= pc)\n        return b;\n    else\n        return c;\n}\nfunction swap16(val) {\n    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);\n}\nfunction checkBitDepth(value) {\n    if (value !== 1 &&\n        value !== 2 &&\n        value !== 4 &&\n        value !== 8 &&\n        value !== 16) {\n        throw new Error(`invalid bit depth: ${value}`);\n    }\n    return value;\n}\n//# sourceMappingURL=PngDecoder.js.map","import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { pngSignature, crc } from './common';\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod, } from './internalTypes';\nconst defaultZlibOptions = {\n    level: 3,\n};\nexport default class PngEncoder extends IOBuffer {\n    constructor(data, options = {}) {\n        super();\n        this._colorType = ColorType.UNKNOWN;\n        this._zlibOptions = Object.assign({}, defaultZlibOptions, options.zlib);\n        this._png = this._checkData(data);\n        this.setBigEndian();\n    }\n    encode() {\n        this.encodeSignature();\n        this.encodeIHDR();\n        this.encodeData();\n        this.encodeIEND();\n        return this.toArray();\n    }\n    // https://www.w3.org/TR/PNG/#5PNG-file-signature\n    encodeSignature() {\n        this.writeBytes(pngSignature);\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    encodeIHDR() {\n        this.writeUint32(13);\n        this.writeChars('IHDR');\n        this.writeUint32(this._png.width);\n        this.writeUint32(this._png.height);\n        this.writeByte(this._png.depth);\n        this.writeByte(this._colorType);\n        this.writeByte(CompressionMethod.DEFLATE);\n        this.writeByte(FilterMethod.ADAPTIVE);\n        this.writeByte(InterlaceMethod.NO_INTERLACE);\n        this.writeCrc(17);\n    }\n    // https://www.w3.org/TR/PNG/#11IEND\n    encodeIEND() {\n        this.writeUint32(0);\n        this.writeChars('IEND');\n        this.writeCrc(4);\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    encodeIDAT(data) {\n        this.writeUint32(data.length);\n        this.writeChars('IDAT');\n        this.writeBytes(data);\n        this.writeCrc(data.length + 4);\n    }\n    encodeData() {\n        const { width, height, channels, depth, data } = this._png;\n        const slotsPerLine = channels * width;\n        const newData = new IOBuffer().setBigEndian();\n        let offset = 0;\n        for (let i = 0; i < height; i++) {\n            newData.writeByte(0); // no filter\n            /* istanbul ignore else */\n            if (depth === 8) {\n                offset = writeDataBytes(data, newData, slotsPerLine, offset);\n            }\n            else if (depth === 16) {\n                offset = writeDataUint16(data, newData, slotsPerLine, offset);\n            }\n            else {\n                throw new Error('unreachable');\n            }\n        }\n        const buffer = newData.toArray();\n        const compressed = deflate(buffer, this._zlibOptions);\n        this.encodeIDAT(compressed);\n    }\n    _checkData(data) {\n        const { colorType, channels, depth } = getColorType(data);\n        const png = {\n            width: checkInteger(data.width, 'width'),\n            height: checkInteger(data.height, 'height'),\n            channels: channels,\n            data: data.data,\n            depth: depth,\n            text: {},\n        };\n        this._colorType = colorType;\n        const expectedSize = png.width * png.height * channels;\n        if (png.data.length !== expectedSize) {\n            throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n        }\n        return png;\n    }\n    writeCrc(length) {\n        this.writeUint32(crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - length, length), length));\n    }\n}\nfunction checkInteger(value, name) {\n    if (Number.isInteger(value) && value > 0) {\n        return value;\n    }\n    throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data) {\n    const { channels = 4, depth = 8 } = data;\n    if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n        throw new RangeError(`unsupported number of channels: ${channels}`);\n    }\n    if (depth !== 8 && depth !== 16) {\n        throw new RangeError(`unsupported bit depth: ${depth}`);\n    }\n    const returnValue = { channels, depth, colorType: ColorType.UNKNOWN };\n    switch (channels) {\n        case 4:\n            returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n            break;\n        case 3:\n            returnValue.colorType = ColorType.TRUECOLOUR;\n            break;\n        case 1:\n            returnValue.colorType = ColorType.GREYSCALE;\n            break;\n        case 2:\n            returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n            break;\n        default:\n            throw new Error('unsupported number of channels');\n    }\n    return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeByte(data[offset++]);\n    }\n    return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeUint16(data[offset++]);\n    }\n    return offset;\n}\n//# sourceMappingURL=PngEncoder.js.map","export var ResolutionUnitSpecifier;\n(function (ResolutionUnitSpecifier) {\n    /**\n     * Unit is unknown\n     */\n    ResolutionUnitSpecifier[ResolutionUnitSpecifier[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n     * Unit is the metre\n     */\n    ResolutionUnitSpecifier[ResolutionUnitSpecifier[\"METRE\"] = 1] = \"METRE\";\n})(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));\n//# sourceMappingURL=types.js.map","import PngDecoder from './PngDecoder';\nimport PngEncoder from './PngEncoder';\nexport * from './types';\nfunction decodePng(data, options) {\n    const decoder = new PngDecoder(data, options);\n    return decoder.decode();\n}\nfunction encodePng(png, options) {\n    const encoder = new PngEncoder(png, options);\n    return encoder.encode();\n}\nexport { decodePng as decode, encodePng as encode };\n//# sourceMappingURL=index.js.map"],"names":["crcTable","n","c","k","initialCrc","InterlaceMethod","FilterMethod","CompressionMethod","ColorType","Uint8Array","uint16","Uint16Array","buffer","defaultZlibOptions","level","PngEncoder","constructor","data","options","super","this","_colorType","_zlibOptions","Object","assign","zlib","_png","_checkData","setBigEndian","encode","encodeSignature","encodeIHDR","encodeData","encodeIEND","toArray","writeBytes","writeUint32","writeChars","width","height","writeByte","depth","writeCrc","encodeIDAT","length","channels","slotsPerLine","newData","offset","i","writeDataBytes","Error","writeDataUint16","compressed","colorType","RangeError","returnValue","getColorType","png","checkInteger","text","expectedSize","currentCrc","updateCrc","byteOffset","value","name","Number","isInteger","TypeError","j","writeUint16","ResolutionUnitSpecifier","encodePng"],"sourceRoot":""}