{"version":3,"file":"85.887945ef5f43bc205112.bundle.js","mappings":"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","sources":["webpack://tweb/./src/config/modes.ts","webpack://tweb/./src/config/tabId.ts","webpack://tweb/./src/environment/ctx.ts","webpack://tweb/./src/helpers/array/findAndSplice.ts","webpack://tweb/./src/helpers/array/indexOfAndSplice.ts","webpack://tweb/./src/helpers/dT.ts","webpack://tweb/./src/helpers/eventListenerBase.ts","webpack://tweb/./src/helpers/makeError.ts","webpack://tweb/./src/lib/mtproto/superMessagePort.ts"],"sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type {TransportType} from '../lib/mtproto/dcConfigurator';\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false,\n  transport: 'websocket' as TransportType,\n  noSharedWorker: location.search.indexOf('noSharedWorker=1') > 0\n};\n\n                       \nModes.http = location.search.indexOf('http=1') > 0;\n         \n\n                                      \n                  \n         \n\nif(Modes.http) {\n  Modes.transport = 'https';\n}\n\n                 \n                             \n         \n\nexport default Modes;\n","const tabId = Date.now() % Math.random() * 100000000 | 0;\nexport default tabId;\n","const ctx = typeof(window) !== 'undefined' ? window : self;\n\nexport default ctx;\n","export default function findAndSplice<T>(array: Array<T>, verify: (value: T, index?: number, array?: Array<T>) => boolean) {\n  const index = array.findIndex(verify);\n  return index !== -1 ? array.splice(index, 1)[0] : undefined;\n};\n","export default function indexOfAndSplice<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  const spliced = idx === -1 ? undefined : array.splice(idx, 1);\n  return spliced?.[0];\n}\n","const _logTimer = Date.now();\nexport default function dT() {\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// import { MOUNT_CLASS_TO } from \"../config/debug\";\nimport type {ArgumentTypes, SuperReturnType} from '../types';\nimport findAndSplice from './array/findAndSplice';\n\n// class EventSystem {\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\n\n//   add(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (listeners === undefined) {\n//         listeners = {};\n//     }\n//     let listenersForEvent = listeners[event];\n//     if (listenersForEvent === undefined) {\n//         listenersForEvent = new Set();\n//     }\n//     listenersForEvent.add(listener);\n//     listeners[event] = listenersForEvent;\n//     //target.addEventListener(event, listener);\n//     this.wm.set(target, listeners);\n//   };\n\n//   remove(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (!listeners) return;\n//     let listenersForEvent = listeners[event];\n//     if (!listenersForEvent) return;\n//     listenersForEvent.delete(listener);\n//   };\n\n//   /* fire(target, event) {\n//      let listeners = this.wm.get(target);\n//      if (!listeners) return;\n//      let listenersForEvent = listeners[event];\n//      if (!listenersForEvent) return;\n//      for (let handler of handlers) {\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous.\n//      }\n//   }; */\n// }\n\n// console.log = () => {};\n\n// const e = new EventSystem();\n// MOUNT_CLASS_TO.e = e;\n\nexport type EventListenerListeners = Record<string, Function>;\n// export type EventListenerListeners = Record<string, (...args: any[]) => any>;\n// export type EventListenerListeners = {[name in string]: Function};\n\n/**\n * Better not to remove listeners during setting\n * Should add listener callback only once\n */\n\ntype ListenerObject<T> = {callback: T, options: boolean | AddEventListenerOptions};\n\n// type EventLitenerCallback<T> = (data: T) =>\n// export default class EventListenerBase<Listeners extends {[name: string]: Function}> {\nexport default class EventListenerBase<Listeners extends EventListenerListeners> {\n  protected listeners: Partial<{\n    [k in keyof Listeners]: Array<ListenerObject<Listeners[k]>>\n  }>;\n  protected listenerResults: Partial<{\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\n  }>;\n\n  private reuseResults: boolean;\n\n  constructor(reuseResults?: boolean) {\n    this._constructor(reuseResults);\n  }\n\n  public _constructor(reuseResults?: boolean): any {\n    this.reuseResults = reuseResults;\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n\n  public addEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\n    (this.listeners[name] ??= []).push({callback, options}); // ! add before because if you don't, you won't be able to delete it from callback\n\n    if(this.listenerResults.hasOwnProperty(name)) {\n      callback(...this.listenerResults[name]);\n\n      if((options as AddEventListenerOptions)?.once) {\n        this.listeners[name].pop();\n        return;\n      }\n    }\n\n    // e.add(this, name, {callback, once});\n  }\n\n  public addMultipleEventsListeners(obj: {\n    [name in keyof Listeners]?: Listeners[name]\n  }) {\n    for(const i in obj) {\n      this.addEventListener(i, obj[i]);\n    }\n  }\n\n  public removeEventListener<T extends keyof Listeners>(\n    name: T,\n    callback: Listeners[T],\n    options?: boolean | AddEventListenerOptions\n  ) {\n    if(this.listeners[name]) {\n      findAndSplice(this.listeners[name], (l) => l.callback === callback);\n    }\n    // e.remove(this, name, callback);\n  }\n\n  protected invokeListenerCallback<T extends keyof Listeners, L extends ListenerObject<any>>(\n    name: T,\n    listener: L,\n    ...args: ArgumentTypes<L['callback']>\n  ) {\n    let result: any, error: any;\n    try {\n      result = listener.callback(...args);\n    } catch(err) {\n      error = err;\n      // console.error('listener callback error', err);\n    }\n\n    if((listener.options as AddEventListenerOptions)?.once) {\n      this.removeEventListener(name, listener.callback);\n    }\n\n    if(error) {\n      throw error;\n    }\n\n    return result;\n  }\n\n  private _dispatchEvent<T extends keyof Listeners>(\n    name: T,\n    collectResults: boolean,\n    ...args: ArgumentTypes<Listeners[T]>\n  ) {\n    if(this.reuseResults) {\n      this.listenerResults[name] = args;\n    }\n\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = collectResults && [];\n\n    const listeners = this.listeners[name];\n    if(listeners) {\n      // ! this one will guarantee execution even if delete another listener during setting\n      const left = listeners.slice();\n      left.forEach((listener) => {\n        const index = listeners.findIndex((l) => l.callback === listener.callback);\n        if(index === -1) {\n          return;\n        }\n\n        const result = this.invokeListenerCallback(name, listener, ...args);\n        if(arr) {\n          arr.push(result);\n        }\n      });\n    }\n\n    return arr;\n  }\n\n  public dispatchResultableEvent<T extends keyof Listeners>(name: T, ...args: ArgumentTypes<Listeners[T]>) {\n    return this._dispatchEvent(name, true, ...args);\n  }\n\n  // * must be protected, but who cares\n  public dispatchEvent<L extends EventListenerListeners = Listeners, T extends keyof L = keyof L>(\n    name: T,\n    ...args: ArgumentTypes<L[T]>\n  ) {\n    // @ts-ignore\n    this._dispatchEvent(name, false, ...args);\n  }\n\n  public cleanup() {\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n}\n","const CACHED_ERRORS: {[key in Error['type']]?: ApiError} = {};\nexport default function makeError(type: Error['type']) {\n  return CACHED_ERRORS[type] ??= {\n    type\n  };\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from '../../config/debug';\nimport tabId from '../../config/tabId';\nimport ctx from '../../environment/ctx';\nimport indexOfAndSplice from '../../helpers/array/indexOfAndSplice';\nimport {IS_WORKER} from '../../helpers/context';\nimport EventListenerBase from '../../helpers/eventListenerBase';\nimport makeError from '../../helpers/makeError';\nimport {Awaited, WorkerTaskTemplate, WorkerTaskVoidTemplate} from '../../types';\nimport {logger} from '../logger';\n\ntype SuperMessagePortTask = WorkerTaskTemplate & {\n  transfer?: Transferable[]\n};\n\ninterface InvokeTask extends SuperMessagePortTask {\n  type: 'invoke',\n  payload: WorkerTaskVoidTemplate & {withAck?: boolean, void?: boolean}\n}\n\ninterface ResultTask extends SuperMessagePortTask {\n  type: 'result',\n  payload: {\n    taskId: number,\n    result?: any,\n    error?: any\n  }\n}\n\ninterface AckTask extends SuperMessagePortTask {\n  type: 'ack',\n  payload: {\n    cached: boolean,\n    taskId: number\n    result?: any,\n    error?: any,\n  }\n}\n\ninterface PingTask extends SuperMessagePortTask {\n  type: 'ping'\n}\n\ninterface PongTask extends SuperMessagePortTask {\n  type: 'pong'\n}\n\ninterface BatchTask extends SuperMessagePortTask {\n  type: 'batch',\n  payload: Task[]\n}\n\ninterface CloseTask extends SuperMessagePortTask {\n  type: 'close'\n}\n\n// interface OpenTask extends SuperMessagePortTask {\n//   type: 'open'\n// }\n\ninterface LockTask extends SuperMessagePortTask {\n  type: 'lock',\n  payload: string\n}\n\ntype Task = InvokeTask | ResultTask | AckTask | PingTask | PongTask | BatchTask | CloseTask/*  | OpenTask */ | LockTask;\ntype TaskMap = {\n  [type in Task as type['type']]?: (task: Extract<Task, type>, source: MessageEventSource, event: MessageEvent<any>) => void | Promise<any>\n};\n\nexport type AckedResult<T> = {\n  cached: boolean,\n  result: Promise<T>\n};\n// export type AckedResult<T> = {\n//   cached: true,\n//   result: T\n// } | {\n//   cached: false,\n//   result: Promise<T>\n// };\n\ntype ListenPort = WindowProxy | MessagePort | ServiceWorker | Worker | ServiceWorkerContainer;\ntype SendPort = Pick<MessageEventSource, 'postMessage'>/* WindowProxy | MessagePort | ServiceWorker | Worker */;\n\nexport type MessageListenPort = ListenPort;\nexport type MessageSendPort = SendPort;\n\ntype ListenerCallback = (payload: any, source: MessageEventSource, event: MessageEvent<any>) => any;\ntype Listeners = Record<string, ListenerCallback>;\n\n// const PING_INTERVAL = DEBUG && false ? 0x7FFFFFFF : 5000;\n// const PING_TIMEOUT = DEBUG && false ? 0x7FFFFFFF : 10000;\n\nexport default class SuperMessagePort<\n  Workers extends Listeners,\n  Masters extends Listeners,\n  IsMaster extends boolean,\n  Receive extends Listeners = IsMaster extends true ? Masters : Workers,\n  Send extends Listeners = IsMaster extends true ? Workers : Masters\n> extends EventListenerBase<Receive> {\n  protected listenPorts: Array<ListenPort>;\n  protected sendPorts: Array<SendPort>;\n  protected pingResolves: Map<SendPort, () => void>;\n\n  protected taskId: number;\n  protected awaiting: {\n    [id: number]: {\n      resolve: any,\n      reject: any,\n      taskType: string,\n      port?: SendPort\n    }\n  };\n  protected pending: Map<SendPort, Task[]>;\n\n  protected log: ReturnType<typeof logger>;\n  protected debug: boolean;\n  protected releasingPending: boolean;\n\n  protected processTaskMap: TaskMap;\n\n  protected onPortDisconnect: (source: MessageEventSource) => void;\n  // protected onPortConnect: (source: MessageEventSource) => void;\n\n  protected heldLocks: Map<SendPort, {resolve: () => void, id: string}>;\n  protected requestedLocks: Map<string, SendPort>;\n\n  constructor(protected logSuffix?: string) {\n    super(false);\n\n    this.listenPorts = [];\n    this.sendPorts = [];\n    this.pingResolves = new Map();\n    this.taskId = 0;\n    this.awaiting = {};\n    this.pending = new Map();\n    this.log = logger('MP' + (logSuffix ? '-' + logSuffix : ''));\n    this.debug = DEBUG;\n    this.heldLocks = new Map();\n    this.requestedLocks = new Map();\n\n    this.processTaskMap = {\n      result: this.processResultTask,\n      ack: this.processAckTask,\n      invoke: this.processInvokeTask,\n      ping: this.processPingTask,\n      pong: this.processPongTask,\n      close: this.processCloseTask,\n      // open: this.processOpenTask,\n      lock: this.processLockTask\n    };\n  }\n\n  public setOnPortDisconnect(callback: (source: MessageEventSource) => void) {\n    this.onPortDisconnect = callback;\n  }\n\n  // public setOnPortConnect(callback: (source: MessageEventSource) => void) {\n  //   this.onPortConnect = callback;\n  // }\n\n  public attachPort(port: MessageEventSource) {\n    this.attachListenPort(port);\n    this.attachSendPort(port);\n  }\n\n  public attachListenPort(port: ListenPort) {\n    this.listenPorts.push(port);\n    port.addEventListener('message', this.onMessage as any);\n  }\n\n  public attachSendPort(port: SendPort) {\n    this.log.warn('attaching send port');\n\n    (port as MessagePort).start?.();\n\n    this.sendPorts.push(port);\n    // this.sendPing(port);\n\n    // const task = this.createTask('open', undefined);\n    // this.postMessage(port, task);\n\n    if(typeof(window) !== 'undefined') {\n      if('locks' in navigator) {\n        const id = ['lock', tabId, this.logSuffix || '', Math.random() * 0x7FFFFFFF | 0].join('-');\n        this.log.warn('created lock', id);\n        const promise = new Promise<void>((resolve) => this.heldLocks.set(port, {resolve, id}))\n        .then(() => this.heldLocks.delete(port));\n        navigator.locks.request(id, () => {\n          this.resendLockTask(port);\n          return promise;\n        });\n      } else {\n        window.addEventListener('beforeunload', () => {\n          const task = this.createTask('close', undefined);\n          this.postMessage(undefined, task);\n        });\n      }\n    }\n\n    this.releasePending();\n  }\n\n  public resendLockTask(port: SendPort) {\n    const lock = this.heldLocks.get(port);\n    if(!lock) {\n      return;\n    }\n\n    this.pushTask(this.createTask('lock', lock.id), port);\n  }\n\n  // ! Can't rely on ping because timers can be suspended\n  // protected sendPing(port: SendPort, loop = IS_WORKER) {\n  //   let timeout: number;\n  //   const promise = new Promise<void>((resolve, reject) => {\n  //     this.pingResolves.set(port, resolve);\n  //     this.pushTask(this.createTask('ping', undefined), port);\n\n  //     timeout = ctx.setTimeout(() => {\n  //       reject();\n  //     }, PING_TIMEOUT);\n  //   });\n\n  //   promise.then(() => {\n  //     // this.log('got pong');\n\n  //     clearTimeout(timeout);\n  //     this.pingResolves.delete(port);\n\n  //     if(loop) {\n  //       this.sendPingWithTimeout(port);\n  //     }\n  //   }, () => {\n  //     this.pingResolves.delete(port);\n  //     this.detachPort(port);\n  //   });\n  // }\n\n  // protected sendPingWithTimeout(port: SendPort, timeout = PING_INTERVAL) {\n  //   ctx.setTimeout(() => {\n  //     if(!this.sendPorts.includes(port)) {\n  //       return;\n  //     }\n\n  //     this.sendPing(port);\n  //   }, timeout);\n  // }\n\n  public detachPort(port: ListenPort) {\n    this.log.warn('disconnecting port');\n\n    indexOfAndSplice(this.listenPorts, port);\n    indexOfAndSplice(this.sendPorts, port as any);\n\n    port.removeEventListener?.('message', this.onMessage as any);\n    (port as MessagePort).close?.();\n\n    this.onPortDisconnect?.(port as any);\n\n    const heldLock = this.heldLocks.get(port as SendPort);\n    heldLock?.resolve();\n\n    const error = makeError('PORT_DISCONNECTED');\n    for(const id in this.awaiting) {\n      const task = this.awaiting[id];\n      if(task.port === port) {\n        task.reject(error);\n        delete this.awaiting[id];\n      }\n    }\n  }\n\n  protected postMessage(port: SendPort | SendPort[], task: Task) {\n    const ports = Array.isArray(port) ? port : (port ? [port] : this.sendPorts);\n    ports.forEach((port) => {\n      port.postMessage(task, task.transfer as any);\n    });\n  }\n\n  protected onMessage = (event: MessageEvent) => {\n    const task: Task = event.data;\n    // this.log('got message', task);\n\n    const source: MessageEventSource = event.source || event.currentTarget as any; // can have no source\n    /* if(task.type === 'batch') {\n      const newEvent: MessageEvent = {data: event.data, source: event.source, currentTarget: event.currentTarget} as any;\n      task.payload.forEach((task) => {\n        // @ts-ignore\n        newEvent.data = task;\n        this.onMessage(newEvent);\n      });\n    } */\n\n    // @ts-ignore\n    this.processTaskMap[task.type](task, source, event);\n  };\n\n  protected /* async */ releasePending() {\n    // return;\n\n    if(/* !this.listenPorts.length || !this.sendPorts.length ||  */this.releasingPending) {\n      return;\n    }\n\n    this.releasingPending = true;\n    // const perf = performance.now();\n    // await pause(0);\n\n    this.debug && this.log.debug('releasing tasks, length:', this.pending.size/* , performance.now() - perf */);\n\n    this.pending.forEach((portTasks, port) => {\n      // let batchTask: BatchTask;\n      // const tasks: Task[] = [];\n      // portTasks.forEach((task) => {\n      //   if(task.transfer) {\n      //     batchTask = undefined;\n      //     tasks.push(task);\n      //   } else {\n      //     if(!batchTask) {\n      //       batchTask = this.createTask('batch', []);\n      //       tasks.push(batchTask);\n      //     }\n\n      //     batchTask.payload.push(task);\n      //   }\n      // });\n\n      const tasks = portTasks;\n      const ports = port ? [port] : this.sendPorts;\n      if(!ports.length) {\n        return;\n      }\n\n      tasks.forEach((task) => {\n        // if(task.type === 'batch') {\n        //   this.log(`batching ${task.payload.length} tasks`);\n        // }\n\n        try {\n          // if(IS_SERVICE_WORKER && !port) {\n          //   notifyAll(task);\n          // } else {\n          this.postMessage(ports, task);\n          // }\n        } catch(err) {\n          this.log.error('postMessage error:', err, task, ports);\n        }\n      });\n\n      this.pending.delete(port);\n    });\n\n    this.debug && this.log.debug('released tasks');\n\n    this.releasingPending = false;\n  }\n\n  protected processResultTask = (task: ResultTask) => {\n    const {taskId, result, error} = task.payload;\n    const deferred = this.awaiting[taskId];\n    if(!deferred) {\n      return;\n    }\n\n    this.debug && this.log.debug('done', deferred.taskType, result, error);\n    'error' in task.payload ? deferred.reject(error) : deferred.resolve(result);\n    delete this.awaiting[taskId];\n  };\n\n  protected processAckTask = (task: AckTask) => {\n    const payload = task.payload;\n    const deferred = this.awaiting[payload.taskId];\n    if(!deferred) {\n      return;\n    }\n\n    // * will finish the init promise with incoming result\n    const previousResolve: (acked: AckedResult<any>) => void = deferred.resolve;\n    // const previousReject = deferred.reject;\n\n    // if(payload.cached) {\n    //   if('result' in payload) {\n    //     previousResolve({\n    //       cached: true,\n    //       result: payload.result\n    //     });\n    //   } else {\n    //     previousReject(payload.error);\n    //   }\n    // } else {\n    //   const ret: AckedResult<any> = {\n    //     cached: false,\n    //     result: new Promise((resolve, reject) => {\n    //       deferred.resolve = resolve;\n    //       deferred.reject = reject;\n    //     })\n    //   };\n\n    //   previousResolve(ret);\n    // }\n\n    const ret: AckedResult<any> = {\n      cached: payload.cached,\n      result: payload.cached ? ('result' in payload ? Promise.resolve(payload.result) : Promise.reject(payload.error)) : new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n      })\n    };\n\n    previousResolve(ret);\n\n    if(payload.cached) {\n      delete this.awaiting[payload.taskId];\n    }\n  };\n\n  protected processPingTask = (task: PingTask, source: MessageEventSource, event: MessageEvent) => {\n    this.pushTask(this.createTask('pong', undefined), event.source);\n  };\n\n  protected processPongTask = (task: PongTask, source: MessageEventSource, event: MessageEvent) => {\n    const pingResolve = this.pingResolves.get(source);\n    if(pingResolve) {\n      this.pingResolves.delete(source);\n      pingResolve();\n    }\n  };\n\n  protected processCloseTask = (task: CloseTask, source: MessageEventSource, event: MessageEvent) => {\n    this.detachPort(source);\n  };\n\n  // * it's just an 'open' callback, DO NOT attach port from here\n  // protected processOpenTask = (task: OpenTask, source: MessageEventSource, event: MessageEvent) => {\n  //   this.onPortConnect?.(source);\n  // };\n\n  protected processLockTask = (task: LockTask, source: MessageEventSource, event: MessageEvent) => {\n    const id = task.payload;\n    if(this.requestedLocks.has(id)) {\n      return;\n    }\n\n    this.requestedLocks.set(id, source);\n    navigator.locks.request(id, () => {\n      this.processCloseTask(undefined, source, undefined);\n      this.requestedLocks.delete(id);\n    });\n  };\n\n  protected processInvokeTask = async(task: InvokeTask, source: MessageEventSource, event: MessageEvent) => {\n    const id = task.id;\n    const innerTask = task.payload;\n\n    let resultTaskPayload: ResultTask['payload'];\n    let resultTask: ResultTask, ackTask: AckTask;\n    if(!innerTask.void) {\n      resultTaskPayload = {taskId: id};\n      resultTask = this.createTask('result', resultTaskPayload);\n    }\n\n    if(innerTask.withAck) {\n      ackTask = this.createTask('ack', {\n        taskId: id,\n        cached: true\n      });\n    }\n\n    let isPromise: boolean;\n    try {\n      const listeners = this.listeners[innerTask.type];\n      if(!listeners?.length) {\n        throw new Error('no listener');\n      }\n\n      const listener = listeners[0];\n\n      // @ts-ignore\n      let result = this.invokeListenerCallback(innerTask.type, listener, innerTask.payload, source, event);\n      if(innerTask.void) {\n        return;\n      }\n\n      isPromise = result instanceof Promise;\n\n      if(ackTask) {\n        const cached = !isPromise;\n        ackTask.payload.cached = cached;\n        if(cached) ackTask.payload.result = result;\n        this.pushTask(ackTask, source);\n\n        if(cached) {\n          return;\n        }\n      }\n\n      if(isPromise) {\n        result = await result;\n      }\n\n      resultTaskPayload.result = result;\n    } catch(error) {\n      this.log.error('worker task error:', error, task);\n      if(innerTask.void) {\n        return;\n      }\n\n      if(ackTask && ackTask.payload.cached) {\n        ackTask.payload.error = error;\n        this.pushTask(ackTask, source);\n        return;\n      }\n\n      resultTaskPayload.error = error;\n    }\n\n    this.pushTask(resultTask, source);\n  };\n\n  protected createTask<T extends Task['type'], K extends Task = Parameters<TaskMap[T]>[0]>(type: T, payload: K['payload'], transfer?: Transferable[]): K {\n    return {\n      type,\n      payload,\n      id: this.taskId++,\n      transfer\n    } as K;\n  }\n\n  protected createInvokeTask(type: string, payload: any, withAck?: boolean, _void?: boolean, transfer?: Transferable[]): InvokeTask {\n    return this.createTask('invoke', {\n      type,\n      payload,\n      withAck,\n      void: _void\n    }, transfer);\n  }\n\n  protected pushTask(task: Task, port?: SendPort) {\n    let tasks = this.pending.get(port);\n    if(!tasks) {\n      this.pending.set(port, tasks = []);\n    }\n\n    tasks.push(task);\n    this.releasePending();\n  }\n\n  public invokeVoid<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], port?: SendPort, transfer?: Transferable[]) {\n    const task = this.createInvokeTask(type as string, payload, undefined, true, transfer);\n    this.pushTask(task, port);\n  }\n\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: false, port?: SendPort, transfer?: Transferable[]): Promise<Awaited<ReturnType<Send[T]>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: true, port?: SendPort, transfer?: Transferable[]): Promise<AckedResult<Awaited<ReturnType<Send[T]>>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: boolean, port?: SendPort, transfer?: Transferable[]) {\n    this.debug && this.log.debug('start', type, payload);\n\n    let task: InvokeTask;\n    const promise = new Promise<Awaited<ReturnType<Send[T]>>>((resolve, reject) => {\n      task = this.createInvokeTask(type as string, payload, withAck, undefined, transfer);\n      this.awaiting[task.id] = {resolve, reject, taskType: type as string, port};\n      this.pushTask(task, port);\n    });\n\n    if(IS_WORKER) {\n      promise.finally(() => {\n        clearInterval(interval);\n      });\n\n      const interval = ctx.setInterval(() => {\n        this.log.error('task still has no result', task, port);\n      }, 60e3);\n    } else if(false) {\n      // let timedOut = false;\n      const startTime = Date.now();\n      promise.finally(() => {\n        const elapsedTime = Date.now() - startTime;\n        if(elapsedTime >= TIMEOUT) {\n          this.log.error(`task was processing ${Date.now() - startTime}ms`, task.payload.payload, port);\n        }/*  else {\n          clearTimeout(timeout);\n        } */\n      });\n\n      const TIMEOUT = 10;\n      // const timeout = ctx.setTimeout(() => {\n      //   timedOut = true;\n      //   // this.log.error(`task is processing more than ${TIMEOUT} milliseconds`, task, port);\n      // }, TIMEOUT);\n    }\n\n    return promise;\n  }\n\n  public invokeExceptSource<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], source?: SendPort) {\n    const ports = this.sendPorts.slice();\n    indexOfAndSplice(ports, source);\n\n    ports.forEach((target) => {\n      this.invokeVoid(type, payload, target);\n    });\n  }\n}\n"],"names":["Modes","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","transport","noSharedWorker","Date","now","Math","random","window","self","findAndSplice","array","verify","index","findIndex","splice","undefined","indexOfAndSplice","item","idx","spliced","_logTimer","dT","toFixed","EventListenerBase","constructor","reuseResults","this","_constructor","listeners","listenerResults","addEventListener","name","callback","options","push","hasOwnProperty","once","pop","addMultipleEventsListeners","obj","i","removeEventListener","l","invokeListenerCallback","listener","args","result","error","err","_dispatchEvent","collectResults","arr","slice","forEach","dispatchResultableEvent","dispatchEvent","cleanup","CACHED_ERRORS","makeError","type","SuperMessagePort","logSuffix","super","onMessage","event","task","data","source","currentTarget","processTaskMap","processResultTask","taskId","payload","deferred","awaiting","log","taskType","reject","resolve","processAckTask","previousResolve","cached","Promise","processPingTask","pushTask","createTask","processPongTask","pingResolve","pingResolves","get","delete","processCloseTask","detachPort","processLockTask","id","requestedLocks","has","set","navigator","locks","request","processInvokeTask","innerTask","resultTaskPayload","resultTask","ackTask","isPromise","void","withAck","length","Error","listenPorts","sendPorts","Map","pending","heldLocks","ack","invoke","ping","pong","close","lock","setOnPortDisconnect","onPortDisconnect","attachPort","port","attachListenPort","attachSendPort","warn","start","join","promise","then","resendLockTask","postMessage","releasePending","heldLock","Array","isArray","transfer","releasingPending","size","portTasks","tasks","ports","createInvokeTask","_void","invokeVoid","finally","clearInterval","interval","invokeExceptSource","target"],"sourceRoot":""}