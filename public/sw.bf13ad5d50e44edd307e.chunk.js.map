{"version":3,"file":"sw.bf13ad5d50e44edd307e.chunk.js","mappings":"uBAAIA,ECAAC,E,4CCQG,MACMC,E,QAAoB,QAEpBC,EADuB,oBAAb,OAA2BC,OAASC,KAE3D,G,yECJO,MAAMC,EAAaC,UAAYA,UAAUC,UAAY,KAU/CC,GATWF,UAAUC,UAAUE,OAAO,yBACzBH,UAAUC,UAAUG,cAAcC,QAAQ,WACzC,SAASC,KAAKN,UAAUC,YAAc,aAAaK,KAAKN,UAAUO,SAG7D,mBAAmBD,KAAKN,UAAUQ,WACxC,aAAvBR,UAAUQ,UAA2BR,UAAUS,eAAiB,IAC/D,gBAEwB,oBAAuBV,KAAe,yBAAyBO,KAAKP,IAAkBA,EAAWW,MAAM,YAAcX,EAAWW,MAAM,aACrJC,EAAaX,UAAUC,UAAUG,cAAcC,QAAQ,YAAc,QAI3BO,IAA7BZ,UAAUS,gBAAgCT,UAAUS,eAAiB,IAAMT,UAAUC,UAAUE,OAAO,iH,8DChBzH,MAAMU,EAAwD,oBAA7BC,0BAA4ChB,gBAAgBgB,yBACvFC,EAA6C,oBAAtBC,mBAAqClB,gBAAgBkB,oBAAsBH,EAClGI,EAAYF,GAAiBF,EAE7BK,EAAmB,IACtBpB,KACPqB,QACAC,SAAS,CAACC,qBAAqB,EAAOC,KAAM,WAKzCC,EAAc,CAACC,KAAwDC,KAC3E,IAEED,EAASD,eAAeE,E,CACxB,MAAMC,GACNC,QAAQC,MAAM,8BAA+BF,EAAKD,E,GAIhDI,EAAsB,CAACC,KAAiBL,KAC5CP,IAAmBa,MAAMC,IACnBA,EAAUC,QAKdD,EAAUE,MAAMJ,EAAM,GAAK,GAAGK,SAASX,IACrCD,EAAYC,KAAaC,EAAK,GAC9B,GACF,EASyBZ,GAAoBgB,EAAoBO,KAAK,MAAM,GACvDvB,GAAoBgB,EAAoBO,KAAK,MAAM,E,gDCrChEC,E,wCAAZ,SAAYA,GACV,mBACA,qBACA,mBACA,iBACA,oBACD,CAND,CAAYA,IAAAA,EAAQ,KAQb,MAAMC,EAAa,CAACD,EAASE,KAAMF,EAASG,MAAOH,EAASI,KAAMJ,EAASK,IAAKL,EAASM,OAmB1FC,IAjBY,EAAA1C,WAAa,EAAAS,YA8BlBkC,EAaD,QAbCA,EAgBH,QAiCJC,EAA0I,CAC9I,CAAC,QAAST,EAASM,OACnB,CAAC,OAAQN,EAASK,KAClB,CAAC,OAAQL,EAASI,MAClB,CAAC,QAASJ,EAASG,OACnB,CAAC,SAAUH,EAASG,OACpB,CAAC,QAASH,EAASK,KACnB,CAAC,QAASL,EAASK,KACnB,CAAC,iBAAkBL,EAASK,KAC5B,CAAC,WAAYL,EAASK,MAIjB,SAASK,EAAOC,EAAgB1B,EAAiBe,EAASK,IAAML,EAASI,KAAOJ,EAASG,MAAOS,GAAmB,EAAOC,EAAQ,IACvI,IAAIC,EACA,MAAUF,IACZ3B,EAAOe,EAASG,OAGdI,EAEOM,IACN,KAAmBA,EAAQL,EACtB,OAAeK,EAAQL,IAH/BK,EAAQ,GAMV,MAAME,EAAgBF,EACZA,EAAPA,EAAe,MAAMA,MACX,KAIb,MAAMG,EAAc,YAAY5B,GAC9B,OAAOH,EAAOe,EAASK,KAAOf,QAAQ0B,IAAIH,GAAO,SAAMF,KAA0CvB,EACnG,EAuBA,OArBAqB,EAAQX,SAAQ,EAAEmB,EAAQC,MACxBF,EAAIC,GAAU,YAAY7B,GACxB,OAAOH,EAAOiC,GAAW5B,QAAQ2B,GAAQJ,GAAO,SAAMF,KAA0CvB,EAClG,CAAC,IAGH4B,EAAIG,UAAY,SAASC,GACvBN,EAAiBM,EACjBT,EAAS,IAAMS,EAAY,GAC7B,EAEAJ,EAAIG,UAAUR,GAEdK,EAAIK,SAAW,SAASC,GACtBrC,EAAOgB,EAAWJ,MAAM,EAAGyB,EAAQ,GAAGC,QAAO,CAACC,EAAKC,IAAMD,EAAMC,GAAG,EACpE,EAEAT,EAAIU,WAAa,SAASf,GACxB,OAAOD,EAAO,GAAGI,OAAoBH,IAAU1B,EAAM2B,EAAkBG,EACzE,EAEOC,CACT,C,oEC9Je,SAASW,EAAMC,GAC5B,OAAO,IAAIC,SAAeC,IACxBC,WAAWD,EAASF,EAAG,GAE3B,CCIA,MAAMI,EAAMvE,KACCwE,EAAoB,eAEjC,SAASC,EAAkBC,GACzB,OAAOA,EAASC,IAA0B,MAApBD,EAASE,MACjC,CAEA,SAASC,EAAoCC,GAC3C,OAAOV,QAAQW,KAAK,CAClBD,EACAZ,EAAM,KAAOjC,MAAK,IAAMmC,QAAQY,YAEpC,CCpBe,SAASC,IAAQ,CCuBjB,SAASC,IACtB,MAAMC,EAAsB,CAC1BC,aAAa,EACbC,YAAY,EAEZC,OAAQ,OACRC,UAAW,IAAI5D,KACbwD,EAAeK,WAAa7D,EAC5BwD,EAAejD,UAAUG,SAASoD,GAAkBA,KAAY9D,IAAM,EAGxEO,UAAW,GACXwD,kBAAoBD,IACfN,EAAeK,YAChBC,KAAYN,EAAeK,YAG7BL,EAAejD,UAAUyD,KAAKF,EAAS,GAIrC9F,EAAkC,IAAIyE,SAAW,CAACC,EAASW,KAC/DG,EAAed,QAAWuB,IACrBjG,EAASyF,aAAezF,EAAS0F,aAEpC1F,EAASyF,aAAc,EACvBf,EAAQuB,GAAM,EAGhBT,EAAeH,OAAS,IAAIrD,KACvBhC,EAAS0F,YAAc1F,EAASyF,cAEnCzF,EAAS0F,YAAa,EACtBL,KAAUrD,GAAK,CAChB,IAoBH,OAXAhC,EAASkG,MAAMZ,GAAMa,SAAQ,KAC3BnG,EAAS2F,OAAS3F,EAAS4F,UAAY5F,EAAS6F,WAAa,KAC7D7F,EAASuC,UAAUC,OAAS,EAEzBxC,EAASoG,SACVpG,EAASoG,OAASd,E,IAItBe,OAAOC,OAAOtG,EAAUwF,GAEjBxF,CACT,C,wBCjEe,SAASuG,EAA6CC,EAAyBC,EAAmB,IAC3GC,MAAMC,QAAQH,KAChBA,EAAY,CAACA,IAGf,MAAMI,ECNO,SAA0BH,GACvC,OAgByB,IAhBtB,CACD,aACA,YACA,YACA,gBACA,aACA,YACA,YACA,aACA,kBACA,YACA,aACA,YACA,YACA,mBACA,mBACA7F,QAAQ6F,GACD,2BAGFA,CACT,CDhBuBI,CAAiBJ,GAEtC,OADa,IAAIK,KAAKN,EAAW,CAAC3E,KAAM+E,GAE1C,CEZe,MAAMG,EAGnBC,YACUP,EACAQ,EACAC,GAFA,KAAAT,SAAAA,EACA,KAAAQ,KAAAA,EACA,KAAAC,iBAAAA,EAERC,KAAKC,MAAQ,IAAIC,WAAWJ,EAC9B,CAEaK,MAAMC,EAAkBC,G,qCAEnC,MAAMC,EAAYD,EAASD,EAAKG,WAChC,GAAGD,EAAYN,KAAKC,MAAMM,WAAY,CACpC,MAAMC,EAAW,IAAIN,WAAWI,GAChCE,EAASC,IAAIT,KAAKC,MAAO,GACzBD,KAAKC,MAAQO,C,CAGfR,KAAKC,MAAMQ,IAAIL,EAAMC,EACvB,E,+RAEOK,WACLV,KAAKC,MAAQ,IAAIC,UACnB,CAEOS,KAAKb,GACVE,KAAKC,MAAQD,KAAKC,MAAM3E,MAAM,EAAGwE,EACnC,CAEOc,SAASC,GAAgB,GAC9B,MAAMC,EAAO1B,EAAcY,KAAKC,MAAOD,KAAKV,UAM5C,OAJGuB,GAAiBb,KAAKD,kBACvBC,KAAKD,iBAAiBe,GAGjBA,CACT,CAEOC,WACL,OAAOf,KAAKC,KACd,CAEOe,aAAaC,GAClBjB,KAAKC,MAAQgB,CACf,E,cCxCa,MAAMC,EAQnBrB,YAAoBsB,GAAA,KAAAA,OAAAA,EAJZ,KAAAC,YAAa,EAKhB,WACDpB,KAAKmB,QAAU,SAGdD,EAAuBG,SAAShG,SACjC2E,KAAKoB,WAAaF,EAAuBG,SAAS,GAAGD,YAGvDpB,KAAKsB,eACLJ,EAAuBG,SAASxC,KAAKmB,KACvC,CAEQsB,e,MACN,OAAyB,QAAlB,EAAAtB,KAAKuB,qBAAa,QAAKvB,KAAKuB,cAAgBC,OAAOC,KAAKzB,KAAKmB,OACtE,CAEOO,OAAOC,GACZ,OAAO3B,KAAK4B,kBAAkBC,GAAUA,EAAMH,OAAO,IAAMC,IAC7D,CAEOG,YACL,OAAON,OAAOE,OAAO1B,KAAKmB,OAC5B,CAEOY,IAAIJ,GACT,OAAO3B,KAAK4B,kBAAkBC,GAAUA,EAAM/H,MAAM,IAAM6H,IAC5D,CAEOK,KAAKL,EAAmB/D,GAE7B,OAAOoC,KAAK4B,kBAAkBC,GAAUA,EAAMI,IAAI,IAAMN,EAAW/D,IACrE,CAEOsE,QAAQC,EAAkBzF,EAAmC,QAOlE,OAAOsD,KAAK+B,IAAII,GAAUhH,MAAMyC,IAC9B,IAAIA,EAEF,MAAM,EAAAwE,EAAA,GAAU,kBAOlB,OAJgBxE,EAASlB,IAIX,GAElB,CAEO2F,SAASF,EAAkBrB,GAE3BA,aAAgBnB,OACnBmB,EAAO1B,EAAc0B,IAGvB,MAAMlD,EAAW,IAAI0E,SAASxB,EAAM,CAClCyB,QAAS,CACP,iBAAkB,GAAKzB,EAAKhB,QAIhC,OAAOE,KAAKgC,KAAKG,EAAUvE,GAAUzC,MAAK,IAAM2F,GAClD,CAEOc,iBAAoBjD,GACzB,OAAIqB,KAAKoB,WAIF,IAAI9D,SAAW,CAAMC,EAASW,KAAW,O,EAAA,K,OAAA,E,EAAA,YAC9C,IAAIsE,GAAW,EACf,MAAMC,EAAUjF,YAAW,KACzBU,IAEAsE,GAAW,CAAI,GACd,MAEH,IACE,MAAMX,QAAc7B,KAAKsB,eACzB,IAAIO,EAGF,MAFA7B,KAAKoB,YAAa,EAClBpB,KAAKuB,mBAAgBvH,EACf,YAGR,MAAM0I,QAAY/D,EAASkD,GAE3B,GAAGW,EAAU,OACbjF,EAAQmF,E,CACR,MAAM5H,GACNoD,EAAOpD,E,CAGT6H,aAAaF,EACf,E,YAzBgD,K,6QAyB9C,IA5BOnF,QAAQY,QAAO,EAAAkE,EAAA,GAAU,mBA6BpC,CAEOQ,eAAeT,EAAkBU,EAAkBvD,GACxD,MAAO,CACLzG,SAAUuF,IACV0E,UAAW,IACM,IAAIlD,EAAaN,EAAUuD,GAAW/B,GAC5Cd,KAAKqC,SAASF,EAAUrB,GAAM/B,OAAM,IAAM+B,MAMzD,CAEOiC,qBAAqBC,EAAkBC,GAC5C,OAAO3F,QAAQpC,IAAI8E,KAAKqB,SAAS6B,KAAKC,IAGpC,GAFAA,EAAQ/B,WAAa4B,EAEjBC,EAIJ,OAAID,OAAJ,EACSG,EAAQrB,W,IAGrB,EAvIe,EAAAT,SAAqC,GCDtD,MAAM+B,EAA2F,IAAIC,IAC/FC,EAAe,IAAIpC,EAAuB,sBAE1CqC,EAA2B,cAgCjCC,aA7BuB,IACdF,EAAa1B,kBAAkBC,GAC7BA,EAAM4B,OAAOtI,MAAMuI,IACxB,MAAMC,EAAmC,IAAIN,IACvCO,EAAYC,KAAKC,MAAQ,IAAO,EACtC,IAAI,MAAMC,KAAWL,EAAU,CAC7B,MAAM5J,EAAQiK,EAAQC,IAAIlK,MAAM,cAC7BA,IAAU6J,EAASM,IAAInK,EAAM,KAC9B6J,EAASlD,IAAI3G,EAAM,GAAIiK,E,CAI3B,MAAMG,EAA2B,GACjC,IAAI,MAAOC,EAAIJ,KAAYJ,EAAU,CACnC,MAAM3F,EAAU6D,EAAM/H,MAAMiK,GAAS5I,MAAMyC,IACzC,IAAKA,EAAS2E,QAAQR,IAAIwB,GAnBlB,OAmB4DK,EAElE,OADAnH,EAAI,4BAA6B0H,GAC1BtC,EAAMH,OAAOqC,EAAS,CAACK,cAAc,EAAMC,YAAY,G,IAIlEH,EAASrF,KAAKb,E,CAGhB,OAAOV,QAAQpC,IAAIgJ,EAAS,OAKN,MAC5BV,aAAY,KACV,MAAMc,EAAqBC,IAC3B,IAAI,MAAOC,EAAaN,KAAad,EACnC,GAAGoB,IAAgBF,EAAoB,CACrC,IAAI,MAAMG,KAAUP,EACFA,EAASO,GACjBvG,SAGVkF,EAAiB1B,OAAO8C,E,IAG3B,MAIH,MAAME,EAAiC,IAAIrB,IAC3C,MAAMsB,EAMJ9E,YAAoB+E,GAAA,KAAAA,KAAAA,EAFZ,KAAAC,cAA6B,IAAIC,IAWjC,KAAAC,QAAU,KAChBL,EAAQhD,OAAO1B,KAAKmE,GAAG,EATvBnE,KAAKmE,GAAKQ,EAAOK,MAAMJ,GACvBF,EAAQjE,IAAIT,KAAKmE,GAAInE,MAGrBA,KAAKiF,UAAYL,EAAK9E,KAAO,SAAqBoF,EAA2BC,EAC7EnF,KAAKoF,iBCrEM,SACbC,EACAhI,EACAiI,GAAiB,EACjBC,GAAgB,GAEhB,IAAIC,EACAC,EAAiDlI,EAAgCW,EACjFwH,GAAa,EAEjB,MAAMC,EAAU9K,IACd,MAAM+K,EAAWrI,EAASsI,EAAU3H,EACpC,IAEE0H,EADeP,EAAGS,MAAM,KAAMjL,G,CAE9B,MAAMC,GACNC,QAAQC,MAAM,iBAAkBF,GAEhC+K,EAAQ/K,E,GAINiL,EAAW,IAAIlL,KACf4K,IAAgBA,EAAiB,IAAInI,SAAQ,CAACsI,EAAUC,KAAatI,EAAUqI,EAAU1H,EAAS2H,MAEnGL,GACD7C,aAAa6C,GACbE,GAAa,EACbxH,IACAuH,EAAiB,IAAInI,SAAQ,CAACsI,EAAUC,KAAatI,EAAUqI,EAAU1H,EAAS2H,MAC1EP,IACRK,EAAO9K,GACP6K,GAAa,GAGf,MAAMM,EAAkB,gBAAe,MAElCT,GAAmBD,IAAkBI,GACtCC,EAAO9K,GAIN2K,IAAmBQ,IACpBR,EAAiBC,EAAiBlI,EAAUW,OAASlE,EACrD0L,GAAa,E,GAEdrI,GAIH,OAFAmI,EAAiBQ,EACjBP,EAAe1G,MAAMZ,GACdsH,CAAc,EAcvB,OAXAM,EAASpD,aAAe,KACnB6C,IACD,iBAAiBA,GACjBtH,IACAsH,EAAiBC,EAAiBlI,EAAUW,OAASlE,EACrD0L,GAAa,E,EAIjBK,EAASE,YAAc,MAAQT,EAExBO,CACT,CDI4BA,CAAS/F,KAAK+E,QAAS,MAAQ,GAAO,EAChE,CAMcmB,0BAA0BC,EAAuBC,EAAeC,GAAc,G,qCAC1F,MAAMC,EAA6C,CACjDC,MAAOvG,KAAKmE,GACZqC,KAAMxG,KAAK4E,KAAK4B,KAChBnG,OAAQ8F,EACRC,SAGI3B,EAASgC,KAAKC,UAAUJ,GAExBhC,EAAqBC,IAC3B,IAAIL,EAAWd,EAAiBrB,IAAIuC,GAChCJ,GACFd,EAAiB3C,IAAI6D,EAAoBJ,EAAW,CAAC,GAGvD,IAAIrL,EAAWqL,EAASO,GACxB,GAAG5L,EACD,OAAOA,EAASsC,MAAMwL,GAAeA,EAAW1G,QAGlDD,KAAK6E,cAAc+B,IAAIT,GAEvBtN,EAAWqL,EAASO,GAAUrG,IAE9ByI,GAAmBlB,OAAO,kBAAmBW,OAAStM,EAAWsK,GAChEnJ,KAAKtC,EAAS0E,QAAS1E,EAASqF,QAAQc,SAAQ,KAC5CkF,EAASO,KAAY5L,WACfqL,EAASO,GAEZvF,OAAOuE,KAAKS,GAAU7I,QACxB+H,EAAiB1B,OAAO4C,G,IAK9B,MAAMwC,EAAejO,EAASsC,MAAMwL,GAAeA,EAAW1G,QAO9D,OAJED,KAAK+G,iBAAiBD,EAAcX,EAAeC,IAClDC,GAAerG,KAAKgH,cAAcb,EAAeA,EAAkC,GAAjBnG,KAAKiF,WAGnE6B,CACT,E,+RAEQG,yBAAyBd,EAAuBC,EAAeC,GAKrE,MAAMa,EAAMlH,KAAKmH,YAAYhB,EAAeC,GAC5C,OAAO9C,EAAapB,QAAQgF,GAAK/L,MAAM2F,GAC9BuF,EAAc,IAAInG,WErIhB,SAA8BY,GAC3C,OCDa,SAA+BA,GAC5C,OCGa,SAAoBA,EAAYpE,GAE7C,OAAO,IAAIY,SAAcC,IACvB,MAAM6J,EAAS,IAAIC,WACnBD,EAAOE,iBAAiB,WAAYC,IAElChK,EAAQgK,EAAEC,OAAOC,OAAO,IAE1BL,EAAa,kBAAEtG,EAAK,GAExB,CDbS4G,CAAW5G,EACpB,CDDS6G,CAAsB7G,GAAM3F,MAAMyM,GAAW,IAAI1H,WAAW0H,IACrE,CFmI8CC,CAAqB/G,KAC3D9F,IACCA,EAAMN,I,GAIb,CAEQoN,gBAAgB3B,EAAuBC,EAAeC,GAC5D,OAAOrG,KAAKiH,yBAAyBd,EAAeC,EAAOC,GAAalL,MAAM8E,GACrEA,GAASD,KAAKkG,0BAA0BC,EAAeC,EAAOC,IAEzE,CAEQU,iBAAiBlO,EAA+BsN,EAAuBC,GAC7E,OAAOvN,EAASsC,MAAM8E,IACpB,MAAMiH,EAAMlH,KAAKmH,YAAYhB,EAAeC,GACtCxI,EAAW,IAAI0E,SAASrC,EAAO,CACnCsC,QAAS,CACP,iBAAkB,GAAKtC,EAAM5E,OAC7B,eAAgB,2BAChB,CAACkI,GAA2B,IAAMM,KAAKC,MAAQ,IAAO,MAI1D,OAAOR,EAAatB,KAAKkF,EAAKtJ,EAAS,GAE3C,CAEQmK,aAAa1H,GAChBL,KAAK6E,cAAcZ,IAAI5D,KAI1BL,KAAK6E,cAAc+B,IAAIvG,GACvBL,KAAK8H,gBAAgBzH,EAAQL,KAAKiF,WAAW,GAC/C,CAEQ+B,cAAc3G,EAAgB2H,GAKpC,GAJGA,EAAMhI,KAAK4E,KAAK9E,OACjBkI,EAAMhI,KAAK4E,KAAK9E,MAGdO,EAGF,KAAMA,EAAS2H,EAAK3H,GAAUL,KAAKiF,UACjCjF,KAAK+H,aAAa1H,QAHpBL,KAAK+H,aAAaE,EAAY5H,EAAQL,KAAKiF,WAM/C,CAEOiD,aAAaC,GAClBnI,KAAKoF,mBAEL,MAAMgD,EA2EV,SAAqCD,EAAoB7I,EAAkBQ,GACzE,OAAgB,IAAbqI,EAAM,IAAyB,IAAbA,EAAM,GAClB,IAAI7F,SAAS,IAAIpC,WAAW,GAAG0H,OAAQ,CAC5C9J,OAAQ,IACRuK,WAAY,kBACZ9F,QAAS,CACP,gBAAiB,QACjB,gBAAiB,aAAazC,GAAQ,MACtC,iBAAkB,IAClB,eAAgBR,GAAY,eAK3B,IACT,CA1F6BgJ,CAA4BH,EAAOnI,KAAK4E,KAAKtF,SAAUU,KAAK4E,KAAK9E,MAC1F,GAAGsI,EACD,OAAOA,EAGT,IAAK/H,EAAQ2H,GAAOG,EAQpB,MAAM/B,EAAQ4B,GAAOA,EAAMhI,KAAKiF,UAoGpC,SAAoBmB,GAClB,OAAO,WAAKmC,KAAKC,KAAKD,KAAK9L,IAAI2J,GAASmC,KAAK9L,IAAI,IACnD,CAtGgDgM,CAAWT,EAAM3H,EAAS,GAAKL,KAAKiF,UAC1EkB,EAAgB8B,EAAY5H,EAAQ+F,GAM1C,OAJI4B,IACFA,EAAMO,KAAKG,IAAIrI,EAAS+F,EAAOpG,KAAK4E,KAAK9E,KAAO,IAG3CE,KAAK8H,gBAAgB3B,EAAeC,GAAOjL,MAAMwN,IAInDtI,IAAW8F,GAAiB6B,IAAS7B,EAAgBC,IACtDuC,EAAKA,EAAGrN,MAAM+E,EAAS8F,EAAe6B,EAAM7B,EAAgB,IAG9D,MAAM5D,EAAkC,CACtC,gBAAiB,QACjB,gBAAiB,SAASlC,KAAUA,EAASsI,EAAGpI,WAAa,KAAKP,KAAK4E,KAAK9E,MAAQ,MACpF,iBAAkB,GAAG6I,EAAGpI,cAS1B,OANGP,KAAK4E,KAAKtF,WACXiD,EAAQ,gBAAkBvC,KAAK4E,KAAKtF,UAK/B,IAAIgD,SAASqG,EAAI,CACtB7K,OAAQ,IACRuK,WAAY,kBACZ9F,WACA,GAGN,CAEQ4E,YAAYhB,EAAuBC,GACzC,OAAOpG,KAAKmE,GAAK,WAAagC,EAAgB,UAAYC,CAC5D,CAEOrD,WAAW6B,G,MAChB,OAAoC,QAA7B,EAAAF,EAAQ3C,IAAI/B,KAAKgF,MAAMJ,WAAM,QAAI,IAAID,EAAOC,EACrD,CAEQ7B,aAAa6B,GACnB,OAAQA,EAAKgE,SAAyDzE,EACxE,EAqCF,MAAMgB,EAA4B,OAC5BD,EAA2B,QAYjC,SAAS+C,EAAY5H,EAAgBwI,EAXR,MAY3B,OAAOxI,EAAUA,EAASwI,CAC5B,C,cKnTe,SAASC,EAAUC,EAAQC,GACxC,MAAMnL,EAAKqB,OAAOuE,KAAMwF,SAAYF,EACpC,OAAOA,GAAKC,GAAY,WAAPC,GAAmBA,WADeD,EAEjDnL,EAAGkL,GAAG1N,SAAWwC,EAAGmL,GAAG3N,QACrBwC,EAAGkL,GAAGG,OAAOhC,GAAQ4B,EAAUC,EAAE7B,GAAM8B,EAAE9B,MACxC6B,IAAMC,CACb,CCkCO,MAAMG,EAUXtJ,YAAYuJ,IClDC,SAAuBC,EAAWC,GAC/C,GAAGA,EACD,IAAI,MAAMC,KAAKD,OACQtP,IAAlBsP,EAAWC,KAEZF,EAAOE,GAAKD,EAAWC,GAM/B,CDwCIC,CAAWxJ,KAAMoJ,GAEd,WACDpJ,KAAKyJ,MAAQ,SAGfzJ,KAAK0J,oBAAqB,EAC1B1J,KAAKvD,KAAM,EAAAN,EAAA,IAAO,CAAC,MAAOiN,EAAGK,MAAME,KAAK,MACxC3J,KAAKvD,IAAI,eAETuD,KAAKsB,cAAa,GAElB6H,EAAIS,UAAU/K,KAAKmB,KACrB,CAEO6J,cACL,OAAO7J,KAAK0J,kBACd,CAEOpI,aAAawI,GAAY,GAC9B,GAAG9J,KAAKuB,gBAAkBuI,EACxB,OAAO9J,KAAKuB,cAGd,MAAMwI,EAAgB,CAACC,EAAoBC,K,MACzC,MAAMC,EAAa3K,MAAM4K,KAAKH,EAAGE,YACjC,IAAI,MAAME,KAAaF,EACrBF,EAAGK,YAAYD,GAGjB,GAAiB,QAAb,EAAAH,EAAMK,eAAO,eAAEjP,OAInB,IAAI,MAAMkP,KAASN,EAAMK,QACpBN,EAAGE,WAAWM,SAASD,EAAMH,YAIhCJ,EAAGS,YAAYF,EAAMH,UAAWG,EAAMG,QAASH,EAAMI,iB,EASzD,IACE,IAAI5G,EAAU6G,UAAUnJ,KAAKzB,KAAKyJ,KAAMzJ,KAAK6K,SAE7C,IAAI9G,EACF,OAAOzG,QAAQY,Q,CAEjB,MAAMlD,GAGN,OAFAgF,KAAKvD,IAAIzB,MAAM,mBAAqBA,EAAgB8P,SACpD9K,KAAK0J,oBAAqB,EACnBpM,QAAQY,OAAOlD,E,CAGxB,IAAI+P,GAAW,EAOf,OANAvN,YAAW,KACLuN,GACFhH,EAAQiH,SAAQ,EAAA5I,EAAA,GAAU,sB,GAE3B,KAEIpC,KAAKuB,cAAgB,IAAIjE,SAAqB,CAACC,EAASW,KAC7D6F,EAAQkH,UAAaC,IACnBH,GAAW,EACX,MAAM3B,EAAKrF,EAAQ0D,OACnB,IAAI0D,GAAY,EAEhBnL,KAAKvD,IAAI,UAET2M,EAAG4B,QAAWhQ,IACZgF,KAAK0J,oBAAqB,EAC1B1J,KAAKvD,IAAIzB,MAAM,8CAA+CA,GAC9DkD,EAAOlD,EAAM,EAGfoO,EAAGgC,QAAW7D,IACZvH,KAAKvD,IAAIzB,MAAM,UAAWuM,IACzB4D,GAAanL,KAAKsB,cAAc,EAGnC8H,EAAGiC,QAAW9D,IACZvH,KAAKvD,IAAIzB,MAAM,SAAUuM,GACzB,MAAM+D,EAAc/D,EAAEC,OAEtBxH,KAAKsB,aAAa6J,GAAY,GAE3BG,EAAYN,SACbM,EAAYN,QAAQzD,GAGtB6B,EAAGmC,OAAO,EAGZnC,EAAGoC,gBAAmBjE,IACpBvH,KAAKvD,IAAIzB,MAAM,wBAAwB,EAGzCuC,EAAQyC,KAAKoJ,GAAKA,EAAG,EAGvBrF,EAAQiH,QAAWE,IACjBH,GAAW,EACX/K,KAAK0J,oBAAqB,EAC1B1J,KAAKvD,IAAIzB,MAAM,8CAA+CkQ,GAC9DhN,EAAOgN,EAAM,EAGfnH,EAAQ0H,gBAAmBP,IACzBH,GAAW,EACX/K,KAAKvD,IAAIiP,KAAK,8BAA+BR,EAAMS,WAAY,KAAMT,EAAMU,YAE3E,MAAMpE,EAAS0D,EAAM1D,OACf4B,EAAK5B,EAAOC,OAClBzH,KAAK6L,OAAOtQ,SAAS0O,IAOnB,GAAIb,EAAG0C,iBAAiBtB,SAASP,EAAMR,MAEhC,CACL,MACMO,EADMxC,EAAO8D,YACJS,YAAY9B,EAAMR,MACjCM,EAAcC,EAAIC,E,KAxFA,EAACb,EAAiBa,KAC1C,MAAMD,EAAKZ,EAAG4C,kBAAkB/B,EAAMR,MACtCM,EAAcC,EAAIC,EAAM,EAkFlB+B,CAAkB5C,EAAIa,E,GAMxB,CACH,GAEL,CAEOlH,cAAuCqG,G,MAC5C,OAAmE,QAA5D,EAAApJ,KAAK4J,UAAUqC,MAAMC,GAAaA,EAASzC,OAASL,EAAGK,cAAK,QAAI,IAAIN,EAAIC,EACjF,CAEOrG,sBAAsBoJ,GAC3BnM,KAAK4J,UAAUrO,SAAS4H,IACtB,GAAGgJ,GAAYA,IAAahJ,EAC1B,OAGF,MAAMiG,EAAKjG,EAAQiG,GAChBA,IACDA,EAAGgC,QAAU,OACbhC,EAAGmC,Q,GAGT,EApKe,EAAA3B,UAAmB,GAuKrB,MAAMwC,EAKnBvM,YAAYuJ,EAAOiD,GACjBrM,KAAKqM,UAAYA,EACjBrM,KAAKvD,KAAM,EAAAN,EAAA,IAAO,CAAC,MAAOiN,EAAGK,KAAM4C,GAAW1C,KAAK,MACnD3J,KAAKsM,IAAMnD,EAAIoD,OAAOnD,EACxB,CAoCO1H,OAAOC,EAA8B0K,GAE1C,MAAM7M,EAAUD,MAAMC,QAAQmC,GAK9B,OAJInC,IACFmC,EAAY,GAAG6K,OAAO7K,IAGjB3B,KAAKyM,eAAe,aAAcV,IACvC,MAAM7H,EAAYvC,EAAuBuB,KAAKvB,GAAcoK,EAAYrK,OAAOC,KAC/E,OAAOnC,EAAU0E,EAAWA,EAAS,EAAE,GACoB,GAAImI,EACnE,CAEOK,MAAML,GACX,OAAOrM,KAAKyM,eAAe,aAAcV,GAAgBA,EAAYW,SAA2B,GAAIL,EACtG,CAEOrK,KAAKL,EAA8B7C,EAAoBuN,GAY5D,MAAM7M,EAAUD,MAAMC,QAAQmC,GAM9B,OALInC,IACFmC,EAAY,GAAG6K,OAAO7K,GACtB7C,EAAQ,GAAG0N,OAAO1N,IAGbkB,KAAKyM,eAAe,aAAcV,IACvC,MAAM7H,EAAYvC,EAAuBuB,KAAI,CAACvB,EAAWgL,IAAQZ,EAAY9J,IAAInD,EAAM6N,GAAMhL,KAC7F,OAAOnC,EAAU0E,EAAWA,EAAS,EAAE,GACkB,GAAImI,EACjE,CA6EOtK,IAAOJ,EAA8B0K,GAG1C,MAAM7M,EAAUD,MAAMC,QAAQmC,GAC9B,GAAInC,GAMG,IAAImC,EAAUtG,OACnB,OAAOiC,QAAQC,QAAQ,QAPZ,CACX,IAAIoE,EACF,OAGFA,EAAY,GAAG6K,OAAO7K,E,CAKxB,OAAO3B,KAAKyM,eAAkB,YAAaV,IACzC,MAAM7H,EAAYvC,EAAuBuB,KAAKvB,GAAcoK,EAAYhK,IAAIJ,KAC5E,OAAOnC,EAAU0E,EAAWA,EAAS,EAAE,GACiB,GAAImI,EAChE,CAEQI,eACNG,EACAjO,EACAlC,EACA4P,EAAYrM,KAAKqM,WAEjB,IAAIQ,EAOJ,OALGpQ,IACDoQ,EAAOC,YAAYhJ,MACnB9D,KAAKvD,IAAIA,EAAM,YAGVuD,KAAKsM,IAAIhL,eAAenG,MAAMiO,GAC5B,IAAI9L,SAAW,CAACC,EAASW,KAK9B,MAAMoN,EAAclC,EAAGkC,YAAY,CAACe,GAAYO,GAE1CG,EAAU,KACdpK,aAAaF,GACbvE,EAAOoN,EAAYtQ,MAAM,EAIrBgS,EAAa,KACjBrK,aAAaF,GAEVhG,GACDuD,KAAKvD,IAAIA,EAAM,QAASqQ,YAAYhJ,MAAQ+I,GAQ9C,MAAMI,EAAUvJ,EAASR,KAAKgK,GAAMA,EAAEzF,SACtClK,EAAQiC,EAAUyN,EAAUA,EAAQ,GAAG,EAGzC3B,EAAYN,QAAU+B,EAGtB,MAAMI,EAAsC,cAATP,EAChCO,IACD7B,EAAY8B,WAAa,IAAMJ,KAGjC,MAAMvK,EAAUjF,YAAW,KACzBwC,KAAKvD,IAAIzB,MAAM,2BAA4BsQ,EAAa7O,EAAI,GAC3D,KAOG4Q,EAAiB1O,EAAS2M,EAAYS,YAAYM,IAElD7M,EAAUD,MAAMC,QAAQ6N,GACxB3J,EAAyBlE,EAAU6N,EAAiB,GAAGb,OAAOa,GAEpE,GAAGF,EACD,OAGF,MAAM9R,EAASqI,EAASrI,OACxB,IAAIiS,EAAOjS,EAEX,MAAMkS,EAAoB,KACrBjC,EAAYtQ,SAITsS,GACJN,G,EAIJ,IAAI,IAAIzD,EAAI,EAAGA,EAAIlO,IAAUkO,EAAG,CAC9B,MAAMxF,EAAUL,EAAS6F,GACzBxF,EAAQiH,QAAU+B,EAClBhJ,EAAQkH,UAAYsC,C,MAI5B,CAEOC,OAAUnB,GACf,OAAOrM,KAAKyM,eAAoB,YAAaV,GAAgBA,EAAYyB,UAA6B,GAAInB,EAC5G,EE9cF,MAAM,EAAMnT,KACNuU,EAAiB7E,SAAS8E,SAAW,KAAO9E,SAAS+E,SAAW/E,SAASgF,SAASC,MAAM,KAAKvS,MAAM,GAAI,GAAGqO,KAAK,KAAO,IAI5H,IAAImE,EAAe,EACfC,GAA8B,EA4FlC,MAAMC,EAAwB,CAC5BC,gBAAiB,EACjBC,UAAW,CACTC,uBAAwB,yBACxBC,mBAAoB,eACpBC,qBAAsB,YAExBC,cAAe,CAAC,GAGZC,EAAS,IA7Ef,MAIE1O,YACEuJ,EACAiD,EACQ2B,GAAA,KAAAA,SAAAA,EANF,KAAAnM,MAA0B,CAAC,EAUjC7B,KAAKmD,QAAU,IAAIiJ,EAAchD,EAAIiD,EACvC,CAEQmC,WAAoCtH,GAC1C,MAAMvI,EAAWqB,KAAKgO,SAAS9G,GAC/B,MAA4B,mBAAf,EAA4BvI,IAAaA,CACxD,CAEOoD,IAA6BmF,GAClC,OAAGlH,KAAK6B,MAAM4M,eAAevH,GACpBlH,KAAK6B,MAAMqF,GAGJlH,KAAKmD,QAAQpB,IAAImF,GAClB/L,MAAM2D,GAAUA,IAAO,KAA6B,IAAE3D,MAAM2D,GACtEkB,KAAK6B,MAAM4M,eAAevH,GACpBlH,KAAK6B,MAAMqF,IAGpBpI,UAAAA,EAAUkB,KAAKwO,WAAWtH,IAEnBlH,KAAK6B,MAAMqF,GAAOpI,IAE7B,CAEO4P,UAAmCxH,GACxC,MAAMpI,EAAQkB,KAAK+B,IAAImF,GACvB,GAAGpI,aAAiBxB,QAClB,KAAM,cAGR,OAAOwB,CACT,CAEa2B,IAA6ByG,EAAQpI,G,mDAEhD,IAAGgK,EAD2B,QAAf,EAAA9I,KAAK6B,MAAMqF,UAAI,QAAIlH,KAAKgO,SAAS9G,GAC3BpI,GAArB,CAIAkB,KAAK6B,MAAMqF,GAAOpI,EAElB,IACEkB,KAAKmD,QAAQnB,KAAKkF,EAAepI,E,CACjC,MAAMhE,G,yRCjG6F,CACvG2O,KAAM,OACNoB,QAAS,EACTgB,OAAQ,CAAC,CACPpC,KAAM,WACL,CACDA,KAAM,eACL,CACDA,KAAM,SACL,CACDA,KAAM,SACL,CACDA,KAAM,WAaL,CACDA,KAAM,cD6F6E,UAAWuE,GAGlG,IAAI,MAAMzE,KAAKyE,EACbO,EAAOxM,IAAIwH,GAGb,EAAIjC,iBAAiB,QAAS4D,IAC5B,MAAMyD,EAA8BzD,EAAM0D,KAAKC,OAC/CpS,EAAI,OAAQ,OAAF,UAAMkS,IAEhB,IACE,MAAOG,EAAWC,EAAUC,GAAQ,CAClCT,EAAOG,UAAU,mBACjBH,EAAOG,UAAU,iBACjBH,EAAOG,UAAU,cAGbO,EAAUpL,KAAKC,MACrB,GACEoL,KACAJ,GACAG,EAAUH,EAEV,KAAM,yCAAyCvG,KAAKC,MAAMsG,EAAYG,GAAW,WAInF,GAD0BpL,KAAKC,MAAQgK,GAnIjB,OAmIuDC,EAE3E,KAAM,sDAGR,MAAMoB,EAkHV,SAA0BR,EAA6BI,EAAwCC,GAC7F,IAEII,EAFAC,EAAQV,EAAIU,OAAS,WACrBC,EAAOX,EAAIY,aAAe,GAG3BZ,EAAIa,SAEHJ,EADCT,EAAIa,OAAOC,WACH,IAAMd,EAAIa,OAAOC,WAClBd,EAAIa,OAAOE,QACV,IAAMf,EAAIa,OAAOE,QAEjBf,EAAIa,OAAOG,SAAW,IAInChB,EAAIa,OAAOJ,OAAS,GAAKA,EACzB,IAAIQ,EAAM,OAASR,EAEnB,MAAMS,EAAaT,EAAS,IAAMT,EAAIa,OAAOM,OAC7C,GAAGC,EAAe9L,IAAI4L,GAAa,CACjC,MAAM7U,EAAQ,gBAGd,MAFAyB,EAAIiP,KAAK1Q,EAAO2T,GAChBoB,EAAerO,OAAOmO,GAChB7U,C,EAGL+T,aAAQ,EAARA,EAAUiB,aACXX,EAAQ,WACRC,EAAON,EAAKb,uBACZyB,EAAM,gBAGR,MAQMK,EAA2C,CAC/CX,OACAY,KE5TkC,qCF6TlCN,MACAhB,KAAMD,EACNwB,QAbmG,CAAC,CACpGC,OAAQ,SACRf,MAAOL,EAAKZ,qBAYZiC,ME/TmC,4BFgUnCC,OAA8B,MAAtB3B,EAAIa,OAAOc,QAGrB7T,EAAI,cAAe4S,EAAOC,EAAMX,EAAKsB,GAIrC,OAF4B,EAAIM,aAAaC,iBAAiBnB,EAAOY,GAE1ClR,OAAO/D,IAChCyB,EAAIzB,MAAM,4BAA6BA,EAAM,GAEjD,CA3KgCyV,CAAiB9B,EAAKI,EAAUC,GAC5D9D,EAAMwF,UAAUvB,E,CAChB,MAAMrU,GACN2B,EAAI3B,E,KAaR,EAAIwM,iBAAiB,qBAAsB4D,IACzC,MAAMyF,EAAezF,EAAMyF,aAC3BlU,EAAI,wBAAyBkU,GAC7BA,EAAapF,QAEb,MAAM6E,EAASlF,EAAMkF,OACrB,GAAc,WAAXA,GAAuBlB,IAGxB,OAFAzS,EAAI,yBACJ8R,EAAO9N,IAAI,kBAAmBoD,KAAKC,MAAQ,OAI7C,MAAM8K,EAA+B+B,EAAa/B,KAClD,IAAIA,EACF,OAGF,MAAM5Q,EAAU,EAAIzD,QAAQC,SAAS,CACnCE,KAAM,WACLS,MAAMyV,IACPhC,EAAKwB,OAASA,EACdS,EAAsBjC,EACtB,IAAI,IAAIrF,EAAI,EAAGA,EAAIqH,EAAWvV,SAAUkO,EAAG,CACzC,MAAMuH,EAASF,EAAWrH,GAC1B,GAAG,UAAWuH,EAIZ,OAHAA,EAAOC,QACPlK,GAAmBmK,WAAW,YAAaH,EAAqBC,QAChED,OAAsB7W,E,CAK1B,GAAG,EAAIO,QAAQ0W,WACb,OAAO3T,QAAQC,QAAQgR,EAAOxM,IAAI,kBAAkB5G,MAAM4T,GACjD,EAAIxU,QAAQ0W,WAAWlC,EAASmC,SAAWzD,I,IAGrD1O,OAAO/D,IACRyB,EAAIzB,MAAM,yBAA0BA,EAAM,IAG5CkQ,EAAMwF,UAAU1S,EAAQ,IAG1B,EAAIsJ,iBAAiB,qBAYrB,SAA6B4D,GAI7B,IAAiCyF,IAHPzF,EAAMyF,aAI9BQ,EAAczP,OAAOiP,EAHvB,IAZA,MAAMQ,EAAmC,IAAIrM,IAC7C,IAAI+L,EA+CJ,SAAS3B,IACP,OAAO,EAAAnV,UACT,CA+EA,MAAMgW,EAAsC,IAAI1M,IAKhDG,aAAY,KACV,MAAM4N,EAAOvN,KAAKC,MAClBiM,EAAexU,SAAQ,CAAC8V,EAAOnK,KACzBkK,EAAOC,EAAS,KAClBtB,EAAerO,OAAOwF,E,GAExB,GACD,M,sBGrUY,MAAMoK,UAA2D,IAsB9EzR,cACE0R,MAAM,WAEN,OAAmB,wBAAoCvR,KACzD,E,cCxCF,MAAMwR,EAAyC,IAAInO,IAC7CoO,GAAiB,EAAArP,EAAA,GAAU,WAGhClJ,KAAasY,YAAcA,EAI5B,MAAME,EAAY,CAChBC,SAAWrL,IACT,MAAM,GAACnC,GAAMmC,EACb,GAAGkL,EAAYvN,IAAIE,GACjB,OAAO7G,QAAQY,OAAOuT,GAMxB,MAAMG,EAAW,IAAIC,qBAAqB,CAACC,cAAe,IAQpD9T,EAAUI,IAWhB,IAAI2T,EAVJ/T,EAAQ7C,MAAK,KACXqC,YAAW,KACTgU,EAAY9P,OAAOyC,EAAG,GACrB,IAAI,IACN,KACDqN,EAAY9P,OAAOyC,EAAG,IAMxB,MAAM6N,EAAW,IAAIC,eAAe,CAClCC,MAAQC,IACNJ,EAAaI,CAAW,EAG1BlT,OAASmT,IACPpU,EAAQE,OAAOuT,EAAe,GAE/BG,GAQGS,EAAI,+BACL/L,GAAO,CAEVgM,eAAgBN,EAIhBhU,UACA+T,eAMF,OAHAP,EAAY/Q,IAAI0D,EAAIkO,GAGbrU,EAAQe,OAAM,KAAO,MAAM0S,CAAc,GAAE,EAGpDc,cAAe,EAAEpO,KAAIqO,YACnB,MAAMH,EAAOb,EAAYzP,IAAIoC,GAC7B,OAAIkO,EAOGA,EAAKN,WAAWU,QAAQD,GANtBlV,QAAQY,QAMoB,EAGvCwU,iBAAmBvO,IACjB,MAAMkO,EAAOb,EAAYzP,IAAIoC,GAC7B,OAAIkO,GAIJA,EAAKrU,QAAQT,UAGN8U,EAAKN,WAAWxG,SANdjO,QAAQY,QAMa,EAGhCyU,eAAiBxO,IACf,MAAMkO,EAAOb,EAAYzP,IAAIoC,GAC7B,GAAIkO,EAOJ,OAHAA,EAAKrU,QAAQE,SAGNmU,EAAKN,WAAW/W,OAAO,GAalC,SAAS4X,EAAgB1H,EAAmB2H,GAC1C,MAAM7U,EAAUZ,EAAM,KAAKjC,MAAK,KAC9B,MAAMkX,EAAOb,EAAYzP,IAAI8Q,GAC7B,IAAIR,GAASA,EAAKS,KAChB,OAGFT,EAAKS,MAAO,EACZ,MAAMC,EAASV,EAAKC,eAEpB,OADiB,IAAIhQ,SAASyQ,EAAQ,CAACxQ,QAAS8P,EAAK9P,SACtC,IAGjB2I,EAAM8H,YAAYhV,EACpB,CAEA,SAASiV,IACP,GAAGzB,EAAY1R,KACb,IAAI,MAAOqE,EAAIkO,KAASb,EAEtBa,EAAKN,WAAW/W,OAGtB,CC5JA,MAAMnC,EAAwC,CAAC,EAmChC,SAASqa,EAAahI,EAAmB2H,GACtD,MAAM7U,EAAUkN,EAAMnH,QAAQoP,WAC7BhY,MAAMgY,IA1BT,SAAiCA,EAAoBC,G,4CACnD,IACE3W,EAAI,aAAc0W,GAClB,MAAMvE,EAZV,SAAuBuE,GACrB,MAAO,CACLE,MAAOF,EAAS3F,OAAO,SACvB6B,MAAO8D,EAASpR,IAAI,SACpBuR,KAAMH,EAASpR,IAAI,QACnBiC,IAAKmP,EAASpR,IAAI,OAEtB,CAKiBwR,CAAcJ,IACT,QAAlB,EAACta,EAASua,UAAQ,QAAjBva,EAASua,GAAc,IAAIvU,KAAK+P,E,CACjC,MAAM9T,GACN2B,EAAIiP,KAAK,gCAAiC5Q,E,sRAqB1C0Y,CAAkBL,EAAUjI,EAAMuI,mBAC3BnR,SAASoR,SAAS,SAG3BxI,EAAM8H,YAAYhV,EACpB,CC5BO,MAAMvB,GAAM,EAAAN,EAAA,IAAO,KAAM,WAAiB,WAAiB,KAAAL,IAAe,WAAe,GAC1F,EAAM5C,KAGZ,IAAIya,EACG,MAAMpP,EAAwB,IAAMoP,EAerCC,GAAqBC,IACzBpX,EAAI,mBAAoBoX,EAAO1P,GAAI,iBAAkB2P,GAAiBhU,MAE9C,SAArB+T,EAAOE,WAKVtX,EAAI,UAAW8C,MAAM4K,KAAK2J,KAC1BjN,GAAmBmK,WAAW,aAAShX,EAAW6Z,GAhBpB,CAACA,IAC3BC,GAAiBhU,MAAS6T,IAC5BlX,EAAI,oCARgB,CAACoX,IACvB,MAAMG,EAAU,IAAIC,eACpBpN,GAAmBqN,WAAWP,EAAsBK,EAAQG,OAC5DtN,GAAmBmK,WAAW,YAAQhX,EAAW6Z,EAAQ,CAACG,EAAQI,OAAO,EAMvEC,CAAgBR,G,EAclBS,CAAwBT,GACxBC,GAAiBrT,IAAIoT,EAAO1P,GAAI0P,GDzB3B,SAA2CU,GAChD,MAAMC,EAAM3b,EAAS0b,EAAapQ,IAC9BqQ,WAIG3b,EAAS0b,EAAapQ,IAE7B1H,EAAI,oCAAqC8X,EAAapQ,GAAI,UAAWqQ,EAAInZ,QACzEmZ,EAAIjZ,SAASqT,IACX/H,GAAmBmK,WAAW,QAASpC,EAAM2F,EAAa,IAE9D,CCeEE,CAAkCZ,IAThCpX,EAAIiP,KAAK,wCAAyCmI,EAAO1P,GASlB,EAG9B0C,GAAqB,IAAIyK,EACtCzK,GAAmB6N,2BAA2B,CAC5CC,mBNmLK,SAA+B/E,GACpC,IAAI,MAAMe,KAAgBQ,EACxB,IACE,GAAGvB,GAAOe,EAAaf,MAAQA,EAC7B,SAGFe,EAAapF,QACb4F,EAAczP,OAAOiP,EACZ,CAAT,MAAMpJ,GAAG,CAGb,IAAIvJ,EAeJ,OAbEA,EADC,qBAAsB,EAAIuS,aACjB,EAAIA,aAAaqE,iBAAiB,CAAChF,QAAMzU,MAAMgW,IACvD,IAAI,IAAI5H,EAAI,EAAGsL,EAAM1D,EAAc9V,OAAQkO,EAAIsL,IAAOtL,EACpD,IACE4H,EAAc5H,GAAGgC,OACR,CAAT,MAAMhE,GAAG,C,IAEZxI,OAAO/D,IACRyB,EAAIzB,MAAM,4BAA6BA,EAAM,IAGrCsC,QAAQC,UAGbS,CACT,EM7ME8W,eAAgB,EAAE9R,UAASC,iBACzB/B,EAAuB6T,cAAc/R,EAASC,EAAW,EAG3D+R,SAAU,CAAC1O,EAASuN,MN0Qf,SAAgBvN,EAAqCuN,GAC1D/F,EAAejK,KAAKC,MACpBiK,EAA8BzH,EAAQ2O,mBAEnCpE,GAAuBgD,IACxBhN,GAAmBmK,WAAW,YAAaH,EAAqBgD,GAChEhD,OAAsB7W,GAGrBsM,EAAQ0I,MACTT,EAAO9N,IAAI,YAAa6F,EAAQ0I,MAG/B1I,EAAQyI,UACTR,EAAO9N,IAAI,gBAAiB6F,EAAQyI,SAExC,CMzRImG,CAAO5O,EAASuN,EAAO,EAGzBsB,MAAO,CAAC7O,EAASuN,KACfD,GAAkBC,EAA8B,EAGlDuB,kBNqRK,SAA6B9O,GAClCyJ,EAAetP,IAAI6F,EAASzC,KAAKC,MACnC,IMpRA,MACE8O,gBAAe,GACfyC,gBAAiBC,IFoDJ,SAAwBzO,GAGrC,OAFAA,EAAmB6N,2BAA2BhD,GAEvC,CACLkB,kBACAyC,gBAAiBpC,EAErB,CE1DIsC,CAAe1O,KAGnB,UAAmB1L,MAAMqa,IACvB/Y,EAAI,OAAO+Y,EAAcna,iCACzBma,EAAcja,SAASgZ,IACrBX,GAAkBW,EAAa,GAC/B,IAGJ,MAAMT,GAA8C,IAAIzQ,IACvDnK,KAAa4a,iBAAmBA,GCnFlB,SACbtP,EACAiR,EACAC,GAEA,MAAMxB,EAAa,CAACyB,EAAiBC,KACnCpR,EAAYqR,iBAAiBF,GAC7BC,GAAYpR,EAAYsR,eAAeF,EAChB,EAGzBpR,EAAYuR,qBDyEoClC,IAChDpX,EAAI,6BAA8BoX,GACXA,aAAkBmC,cAClBlC,GAAiB7P,IAAI4P,EAAO1P,KAKnD2P,GAAiBpS,OAAOmS,EAAO1P,IAC/B1H,EAAI,4BAA6BqX,GAAiBhU,MAC9CgU,GAAiBhU,OACnBrD,EAAIiP,KAAK,mBAENiI,IACD9M,GAAmBoP,WAAWtC,GAC9BA,OAAsB3Z,GAGxBsb,OAdA7Y,EAAIiP,KAAK,qB,IC3E4B,oBAA9B,wBACN,qBAAwD,WAAYnE,GAAM2M,EAAW3M,EAAEsM,OAAQtM,EAAEsM,UACrD,oBAA/B,yBACdK,EAAW,IAAK,MAEhBA,EAAW,IAAK,IAEpB,CDgEAgC,CAAkBrP,IAuBlB,MAAMsP,GAAWjL,IAEf,IACG,EAAA5R,WACoD,IAArD4R,EAAMnH,QAAQC,IAAIvK,QAAQmP,SAASwN,OAAS,MAC5ClL,EAAMnH,QAAQC,IAAIlK,MAAM,oFAExB,OAAOoR,EAAM8H,YrBrGV,SAA4B9H,G,qCACjC,IAEE,MAAMrJ,QAAc9D,EAAYN,EAAI+D,OAAOC,KAAK/D,IAC1C2Y,QAAatY,EAAY8D,EAAM/H,MAAMoR,EAAMnH,QAAS,CAACM,YAAY,KAEvE,GAAGgS,GAAQ1Y,EAAkB0Y,GAC3B,OAAOA,EAGT,MAAM9T,EAAuB,CAAC,KAAQ,KACtC,IAAI3E,QAAiB0Y,MAAMpL,EAAMnH,QAAS,CAACxB,YAC3C,GAAG5E,EAAkBC,GACnBiE,EAAMI,IAAIiJ,EAAMnH,QAASnG,EAAS2Y,cAC7B,GAAuB,MAApB3Y,EAASE,OAAgB,CACjC,MAAMkG,EAAMkH,EAAMnH,QAAQC,IAAIwS,QAAQ,QAAS,IAAM,KAAuB,IAAhBjO,KAAKkO,SAAoB,GACrF7Y,QAAiB0Y,MAAMtS,EAAK,CAACzB,YAC1B5E,EAAkBC,IACnBiE,EAAMI,IAAIiJ,EAAMnH,QAASnG,EAAS2Y,Q,CAItC,OAAO3Y,C,CACP,MAAM9C,GACN,OAAOwb,MAAMpL,EAAMnH,Q,CAEvB,E,+RqB2E6B2S,CAAaxL,IAIxC,IAEE,MAAOyL,EAAO9D,GAAU3H,EAAMnH,QAAQC,IAAI6J,MAAM,KAAKvS,OAAO,GAI5D,OAAOqb,GACL,IAAK,Ud4HI,SAAuBzL,EAAmB2H,GACvD,MAAM1K,EAqCR,SAAoByO,GAClB,IAAIA,EAAQ,MAAO,CAAC,EAAG,GACvB,MAAO,CAAEC,GAAUD,EAAO/I,MAAM,KAC1BiJ,EAASD,EAAOhJ,MAAM,OACrBxN,EAAQ2H,GAAO8O,EAAO,GAAGjJ,MAAM,KAEtC,MAAO,EAAExN,GAAS2H,GAAO,EAC3B,CA5CgB+O,CAAW7L,EAAMnH,QAAQxB,QAAQR,IAAI,UAC7C6C,EAAwB6B,KAAKuQ,MAAMC,mBAAmBpE,IACtDE,EAASpO,EAAO5C,IAAI6C,GAI1BsG,EAAM8H,YAAY1V,QAAQW,KAAK,EACrB,KgBzQH,IAAIX,SAAUC,IACnBC,YAAW,KACTD,EAAQ,IAAI+E,SAAS,GAAI,CACvBxE,OAAQ,IACRuK,WAAY,uBACX,GhBoQG,KgBlQT,KhBmQC0K,EAAO7K,aAAaC,KAExB,CctIQ+O,CAAchM,EAAO2H,GACrB,MAGF,IAAK,WACH,GAAgB3H,EAAO2H,GACvB,MAGF,IAAK,QACHK,EAAahI,GACb,MAGF,IAAK,OACHA,EAAM8H,YAAY,IAAI1Q,SAAS,S,CAInC,MAAMxH,GACN2B,EAAIzB,MAAM,cAAeF,GACzBoQ,EAAM8H,YAAY,IAAI1Q,SAAS,GAAI,CACjCxE,OAAQ,IACRuK,WAAY,wBACZ9F,QAAS,CAAC,gBAAiB,c,GAK3B4U,GAAgB,KACpB,EAAIC,QAAUjB,EAAO,EAGvB,EAAI7O,iBAAiB,WAAY4D,IAC/BzO,EAAI,cACJyO,EAAMwF,UAAU,EAAI2G,cAAclc,MAAK,IAAMsB,EAAI,qBAAoB,IAGvE,EAAI6K,iBAAiB,YAAa4D,IAChCzO,EAAI,aAAc,GAClByO,EAAMwF,UAAU,EAAIlP,OAAOE,OAAOhE,GAAmBvC,MAAK,IAAMsB,EAAI,2BACpEyO,EAAMwF,UAAU,EAAInW,QAAQ+c,QAAQnc,MAAK,IAAMsB,EAAI,qBAAoB,IAWzE,EAAI8a,UAAY,EAAIC,SAAWL,GAE/BA,I,GG5LIM,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB3d,IAAjB4d,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,EAAyBE,GAAY,CAGjDE,QAAS,CAAC,GAOX,OAHAE,EAAoBJ,GAAUG,EAAQA,EAAOD,QAASH,GAG/CI,EAAOD,OACf,CAGAH,EAAoBM,EAAID,EAGxBL,EAAoB3O,EAAI,KAGvB,IAAIkP,EAAsBP,EAAoBQ,OAAEle,EAAW,CAAC,KAAK,IAAO0d,EAAoB,QAE5F,OADsBA,EAAoBQ,EAAED,EAClB,E/BjCvBpf,EAAW,GACf6e,EAAoBQ,EAAI,CAACzQ,EAAQ0Q,EAAU9S,EAAI+S,KAC9C,IAAGD,EAAH,CAMA,IAAIE,EAAeC,IACnB,IAAS/O,EAAI,EAAGA,EAAI1Q,EAASwC,OAAQkO,IAAK,CAGzC,IAFA,IAAK4O,EAAU9S,EAAI+S,GAAYvf,EAAS0Q,GACpCgP,GAAY,EACPC,EAAI,EAAGA,EAAIL,EAAS9c,OAAQmd,MACpB,EAAXJ,GAAsBC,GAAgBD,IAAalZ,OAAOuE,KAAKiU,EAAoBQ,GAAGhP,OAAOhC,GAASwQ,EAAoBQ,EAAEhR,GAAKiR,EAASK,MAC9IL,EAASM,OAAOD,IAAK,IAErBD,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACb1f,EAAS4f,OAAOlP,IAAK,GACrB,IAAI2D,EAAI7H,SACErL,IAANkT,IAAiBzF,EAASyF,EAC/B,CACD,CACA,OAAOzF,CAnBP,CAJC2Q,EAAWA,GAAY,EACvB,IAAI,IAAI7O,EAAI1Q,EAASwC,OAAQkO,EAAI,GAAK1Q,EAAS0Q,EAAI,GAAG,GAAK6O,EAAU7O,IAAK1Q,EAAS0Q,GAAK1Q,EAAS0Q,EAAI,GACrG1Q,EAAS0Q,GAAK,CAAC4O,EAAU9S,EAAI+S,EAqBjB,EgCzBdV,EAAoBgB,EAAI,CAACb,EAASc,KACjC,IAAI,IAAIzR,KAAOyR,EACXjB,EAAoBkB,EAAED,EAAYzR,KAASwQ,EAAoBkB,EAAEf,EAAS3Q,IAC5EhI,OAAO2Z,eAAehB,EAAS3Q,EAAK,CAAE4R,YAAY,EAAM/W,IAAK4W,EAAWzR,IAE1E,ECNDwQ,EAAoBqB,EAAI,CAAC,EAGzBrB,EAAoBnQ,EAAKyR,GACjB1b,QAAQpC,IAAIgE,OAAOuE,KAAKiU,EAAoBqB,GAAG/b,QAAO,CAACkH,EAAUgD,KACvEwQ,EAAoBqB,EAAE7R,GAAK8R,EAAS9U,GAC7BA,IACL,KCNJwT,EAAoBuB,EAAKD,GAEZA,EAAL,kCCFRtB,EAAoBwB,SAAYF,IAEf,ECHjBtB,EAAoByB,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOpZ,MAAQ,IAAIqZ,SAAS,cAAb,EAGhB,CAFE,MAAO9R,GACR,GAAsB,iBAAXtO,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBye,EAAoBkB,EAAI,CAACjK,EAAK2K,IAAUpa,OAAOqa,UAAU9K,eAAe+K,KAAK7K,EAAK2K,G,MCAlF,IAAIG,EACA/B,EAAoByB,EAAEO,gBAAeD,EAAY/B,EAAoByB,EAAEvQ,SAAW,IACtF,IAAI+Q,EAAWjC,EAAoByB,EAAEQ,SACrC,IAAKF,GAAaE,IACbA,EAASC,gBACZH,EAAYE,EAASC,cAAcC,MAC/BJ,GAAW,CACf,IAAIK,EAAUH,EAASI,qBAAqB,UACzCD,EAAQze,SAAQoe,EAAYK,EAAQA,EAAQze,OAAS,GAAGwe,IAC5D,CAID,IAAKJ,EAAW,MAAM,IAAI7d,MAAM,yDAChC6d,EAAYA,EAAUjD,QAAQ,OAAQ,IAAIA,QAAQ,QAAS,IAAIA,QAAQ,YAAa,KACpFkB,EAAoBsC,EAAIP,C,KCfxB,MACE,QAAmC,IAAxB/B,EAAqC,CAC9C,IAAIuC,EAAevC,EAAoBuB,EACnCiB,EAAgBxC,EAAoBnQ,EACpC4S,EAAW,CAAC,EACZC,EAAW,CAAC,EAIhB1C,EAAoBuB,EAAI,SAAUD,GAEhC,OADaiB,EAAajB,IAGvBmB,EAAS1L,eAAeuK,GAAW,IAAMmB,EAASnB,GAAW,GAElE,EACAtB,EAAoBnQ,EAAI,SAAUyR,GAEhC,OADakB,EAAclB,GACbja,OAAM,SAAU/D,GAC5B,IAAIqf,EAAUD,EAAS3L,eAAeuK,GAClCoB,EAASpB,GACT,OACJ,GAAIqB,EAAU,EAAG,CACf,IAAIC,EAAUL,EAAajB,GAQ3B,MAPAhe,EAAM8P,QACJ,iBACAkO,EACA,mCACAsB,EACA,IACFtf,EAAM+I,QAAUuW,EACVtf,CACR,CACA,OAAO,IAAIsC,SAAQ,SAAUC,GAE3BC,YAAW,WACT,IACI+c,EACK1W,KAAKC,MAGdqW,EAASnB,GAAWuB,EACpBH,EAASpB,GAAWqB,EAAU,EAC9B9c,EAAQma,EAAoBnQ,EAAEyR,GAChC,GArCG,IAsCL,GACF,GACF,CACF,CACD,EAjDD,G,MCIA,IAAIwB,EAAkB,CACrB,IAAK,GAgBN9C,EAAoBqB,EAAExP,EAAI,CAACyP,EAAS9U,KAE/BsW,EAAgBxB,IAElBU,cAAchC,EAAoBsC,EAAItC,EAAoBuB,EAAED,GAE9D,EAGD,IAAIyB,EAAqBza,KAAuB,iBAAIA,KAAuB,kBAAK,GAC5E0a,EAA6BD,EAAmB5b,KAAKrD,KAAKif,GAC9DA,EAAmB5b,KAvBC+P,IACnB,IAAKuJ,EAAUwC,EAAaC,GAAWhM,EACvC,IAAI,IAAI+I,KAAYgD,EAChBjD,EAAoBkB,EAAE+B,EAAahD,KACrCD,EAAoBM,EAAEL,GAAYgD,EAAYhD,IAIhD,IADGiD,GAASA,EAAQlD,GACdS,EAAS9c,QACdmf,EAAgBrC,EAAS0C,OAAS,EACnCH,EAA2B9L,EAAK,C,KvCnB7B9V,EAAO4e,EAAoB3O,EAC/B2O,EAAoB3O,EAAI,IAChB2O,EAAoBnQ,EAAE,IAAIpM,KAAKrC,GwCDb4e,EAAoB3O,G","sources":["webpack://tweb/webpack/runtime/chunk loaded","webpack://tweb/webpack/runtime/startup chunk dependencies","webpack://tweb/./src/config/debug.ts","webpack://tweb/./src/environment/userAgent.ts","webpack://tweb/./src/helpers/context.ts","webpack://tweb/./src/lib/logger.ts","webpack://tweb/./src/helpers/schedulers/pause.ts","webpack://tweb/./src/lib/serviceWorker/cache.ts","webpack://tweb/./src/helpers/noop.ts","webpack://tweb/./src/helpers/cancellablePromise.ts","webpack://tweb/./src/helpers/blob/blobConstruct.ts","webpack://tweb/./src/helpers/blob/blobSafeMimeType.ts","webpack://tweb/./src/lib/files/memoryWriter.ts","webpack://tweb/./src/lib/files/cacheStorage.ts","webpack://tweb/./src/lib/serviceWorker/stream.ts","webpack://tweb/./src/helpers/schedulers/debounce.ts","webpack://tweb/./src/helpers/blob/readBlobAsUint8Array.ts","webpack://tweb/./src/helpers/blob/readBlobAsArrayBuffer.ts","webpack://tweb/./src/helpers/blob/readBlobAs.ts","webpack://tweb/./src/helpers/object/deepEqual.ts","webpack://tweb/./src/lib/files/idb.ts","webpack://tweb/./src/helpers/object/safeAssign.ts","webpack://tweb/./src/lib/serviceWorker/push.ts","webpack://tweb/./src/config/databases/state.ts","webpack://tweb/./src/config/notifications.ts","webpack://tweb/./src/lib/serviceWorker/serviceMessagePort.ts","webpack://tweb/./src/lib/serviceWorker/download.ts","webpack://tweb/./src/lib/serviceWorker/share.ts","webpack://tweb/./src/lib/serviceWorker/index.service.ts","webpack://tweb/./src/helpers/listenMessagePort.ts","webpack://tweb/./src/lib/serviceWorker/timeout.ts","webpack://tweb/webpack/bootstrap","webpack://tweb/webpack/runtime/define property getters","webpack://tweb/webpack/runtime/ensure chunk","webpack://tweb/webpack/runtime/get javascript chunk filename","webpack://tweb/webpack/runtime/get mini-css chunk filename","webpack://tweb/webpack/runtime/global","webpack://tweb/webpack/runtime/hasOwnProperty shorthand","webpack://tweb/webpack/runtime/publicPath","webpack://tweb/webpack/runtime/compat","webpack://tweb/webpack/runtime/importScripts chunk loading","webpack://tweb/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(85).then(next);\n};","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from './modes';\n\nexport const IS_BETA = process.env.NODE_ENV !== 'production';\nexport const DEBUG = (IS_BETA || Modes.debug)/*  && false */;\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\nexport default DEBUG;\n\n// let m = DEBUG;\n/* if(!DEBUG) {\n  ctx.sandpitTurtle = () => {\n    //if(!m) {\n      for(let i in MOUNT_CLASS_TO) {\n        ctx[i] = MOUNT_CLASS_TO[i];\n      }\n      //m = true;\n    //}\n\n    //DEBUG = !DEBUG;\n  };\n} */\n\n/* export const superDebug = (object: any, key: string) => {\n  var d = object[key];\n  var beforeStr = '', afterStr = '';\n  for(var r of d) {\n    beforeStr += r.before.hex + '\\n';\n    afterStr += r.after.hex + '\\n';\n  }\n\n  beforeStr = beforeStr.trim();\n  afterStr = afterStr.trim();\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\n\n  var dada = (name: string, str: string) => {\n    var a = document.createElement('a');\n    a.target = '_blank';\n    a.download = name + '.txt';\n    a.href = URL.createObjectURL(new Blob([str], {\n      type: 'text/plain'\n    }));\n    document.body.append(a);\n    a.click();\n  };\n\n  dada(key + '_' + 'before', beforeStr);\n  dada(key + '_' + 'after', afterStr);\n}\n\nMOUNT_CLASS_TO.superDebug = superDebug; */\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport ctx from './ctx';\n\nexport const USER_AGENT = navigator ? navigator.userAgent : null;\nexport const IS_APPLE = navigator.userAgent.search(/OS X|iPhone|iPad|iOS/i) !== -1;\nexport const IS_ANDROID = navigator.userAgent.toLowerCase().indexOf('android') !== -1;\nexport const IS_CHROMIUM = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n\n// https://stackoverflow.com/a/58065241\nexport const IS_APPLE_MOBILE = (/iPad|iPhone|iPod/.test(navigator.platform) ||\n  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&\n  !(ctx as any).MSStream;\n\nexport const IS_SAFARI = !!('safari' in ctx) || !!(USER_AGENT && (/\\b(iPad|iPhone|iPod)\\b/.test(USER_AGENT) || (!!USER_AGENT.match('Safari') && !USER_AGENT.match('Chrome'))))/*  || true */;\nexport const IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\nexport const IS_MOBILE_SAFARI = IS_SAFARI && IS_APPLE_MOBILE;\n\nexport const IS_MOBILE = (navigator.maxTouchPoints === undefined || navigator.maxTouchPoints > 0) && navigator.userAgent.search(/iOS|iPhone OS|Android|BlackBerry|BB10|Series ?[64]0|J2ME|MIDP|opera mini|opera mobi|mobi.+Gecko|Windows Phone/i) != -1;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// в SW может быть сразу две переменных TRUE\nexport const IS_SERVICE_WORKER = typeof ServiceWorkerGlobalScope !== 'undefined' && self instanceof ServiceWorkerGlobalScope;\nexport const IS_WEB_WORKER = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && !IS_SERVICE_WORKER;\nexport const IS_WORKER = IS_WEB_WORKER || IS_SERVICE_WORKER;\n\nexport const getWindowClients = () => {\n  return (self as any as ServiceWorkerGlobalScope)\n  .clients\n  .matchAll({includeUncontrolled: false, type: 'window'});\n};\n\nexport const getLastWindowClient = () => getWindowClients().then((windowClients) => windowClients.slice(-1)[0]);\n\nconst postMessage = (listener: WindowClient | DedicatedWorkerGlobalScope, ...args: any[]) => {\n  try {\n    // @ts-ignore\n    listener.postMessage(...args);\n  } catch(err) {\n    console.error('[worker] postMessage error:', err, args);\n  }\n};\n\nconst notifyServiceWorker = (all: boolean, ...args: any[]) => {\n  getWindowClients().then((listeners) => {\n    if(!listeners.length) {\n      // console.trace('no listeners?', self, listeners);\n      return;\n    }\n\n    listeners.slice(all ? 0 : -1).forEach((listener) => {\n      postMessage(listener, ...args);\n    });\n  });\n};\n\nconst notifyWorker = (...args: any[]) => {\n  postMessage(self as any as DedicatedWorkerGlobalScope, ...args);\n};\n\nconst noop = () => {};\n\nexport const notifySomeone = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, false) : (IS_WEB_WORKER ? notifyWorker : noop);\nexport const notifyAll = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, true) : (IS_WEB_WORKER ? notifyWorker : noop);\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from '../config/debug';\nimport {IS_FIREFOX, IS_SAFARI} from '../environment/userAgent';\nimport {IS_SERVICE_WORKER, IS_WEB_WORKER} from '../helpers/context';\nimport dT from '../helpers/dT';\n\nexport enum LogTypes {\n  None = 0,\n  Error = 1,\n  Warn = 2,\n  Log = 4,\n  Debug = 8\n};\n\nexport const LOG_LEVELS = [LogTypes.None, LogTypes.Error, LogTypes.Warn, LogTypes.Log, LogTypes.Debug];\n\nconst IS_WEBKIT = IS_SAFARI || IS_FIREFOX;\n\n// let getCallerFunctionNameFromLine: (line: string) => string;\n// if(IS_WEBKIT) {\n//   getCallerFunctionNameFromLine = (line) => {\n//     const splitted = line.split('@');\n//     return splitted[0];\n//   };\n// } else {\n//   getCallerFunctionNameFromLine = (line: string) => {\n//     const splitted = line.trim().split(' ');\n//     if(splitted.length === 3) {\n//       return splitted[1].slice(splitted[1].lastIndexOf('.') + 1);\n//     }\n//   };\n// }\n\nconst STYLES_SUPPORTED = !IS_WEBKIT;\n// const LINE_INDEX = IS_WEBKIT ? 2 : 3;\n\n// function getCallerFunctionName() {\n//   const stack = new Error().stack;\n//   const lines = stack.split('\\n');\n//   const line = lines[LINE_INDEX] || lines[lines.length - 1];\n//   // const match = line.match(/\\.([^\\.]+?)\\s/);\n//   // line = match ? match[1] : line.trim();\n//   const caller = getCallerFunctionNameFromLine(line) || '<anonymous>';\n//   return '[' + caller + ']';\n// }\n\nexport const LOGGER_STYLES = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underscore: '\\x1b[4m',\n  blink: '\\x1b[5m',\n  reverse: '\\x1b[7m',\n  hidden: '\\x1b[8m',\n  // Foreground (text) colors\n  fg: {\n    black: '\\x1b[30m',\n    red: '\\x1b[31m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m',\n    white: '\\x1b[37m'\n  },\n  // Background colors\n  bg: {\n    black: '\\x1b[40m',\n    red: '\\x1b[41m',\n    green: '\\x1b[42m',\n    yellow: '\\x1b[43m',\n    blue: '\\x1b[44m',\n    magenta: '\\x1b[45m',\n    cyan: '\\x1b[46m',\n    white: '\\x1b[47m'\n  }\n};\n\nexport type Logger = {\n  (...args: any[]): void;\n  warn(...args: any[]): void;\n  info(...args: any[]): void;\n  error(...args: any[]): void;\n  trace(...args: any[]): void;\n  debug(...args: any[]): void;\n  assert(...args: any[]): void;\n  // log(...args: any[]): void;\n  group(...args: any[]): void;\n  groupCollapsed(...args: any[]): void;\n  groupEnd(...args: any[]): void;\n  setPrefix(newPrefix: string): void;\n  setLevel(level: 0 | 1 | 2 | 3 | 4): void;\n  bindPrefix(prefix: string): Logger;\n};\n\nconst methods: ['debug' | 'info' | 'warn' | 'error' | 'assert' | 'trace'/*  | 'log' */ | 'group' | 'groupCollapsed' | 'groupEnd', LogTypes][] = [\n  ['debug', LogTypes.Debug],\n  ['info', LogTypes.Log],\n  ['warn', LogTypes.Warn],\n  ['error', LogTypes.Error],\n  ['assert', LogTypes.Error],\n  ['trace', LogTypes.Log],\n  ['group', LogTypes.Log],\n  ['groupCollapsed', LogTypes.Log],\n  ['groupEnd', LogTypes.Log]\n  // [\"log\", LogTypes.Log]\n];\n\nexport function logger(prefix: string, type: LogTypes = LogTypes.Log | LogTypes.Warn | LogTypes.Error, ignoreDebugReset = false, style = ''): Logger {\n  let originalPrefix: string;\n  if(!DEBUG && !ignoreDebugReset/*  || true */) {\n    type = LogTypes.Error;\n  }\n\n  if(!STYLES_SUPPORTED) {\n    style = '';\n  } else if(!style) {\n    if(IS_SERVICE_WORKER) style = LOGGER_STYLES.fg.yellow;\n    else if(IS_WEB_WORKER) style = LOGGER_STYLES.fg.cyan;\n  }\n\n  const originalStyle = style;\n  if(style) style = `%s ${style}%s`;\n  else style = '%s';\n\n  // level = LogLevels.log | LogLevels.warn | LogLevels.error | LogLevels.debug\n\n  const log: Logger = function(...args: any[]) {\n    return type & LogTypes.Log && console.log(style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\n  } as any;\n\n  methods.forEach(([method, logType]) => {\n    log[method] = function(...args: any[]) {\n      return type & logType && console[method](style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\n    };\n  });\n\n  log.setPrefix = function(newPrefix: string) {\n    originalPrefix = newPrefix;\n    prefix = '[' + newPrefix + ']';\n  };\n\n  log.setPrefix(prefix);\n\n  log.setLevel = function(level: 0 | 1 | 2 | 3 | 4) {\n    type = LOG_LEVELS.slice(0, level + 1).reduce((acc, v) => acc | v, 0) as any;\n  };\n\n  log.bindPrefix = function(prefix: string) {\n    return logger(`${originalPrefix}] [${prefix}`, type, ignoreDebugReset, originalStyle);\n  };\n\n  return log;\n};\n","export default function pause(ms: number) {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport pause from '../../helpers/schedulers/pause';\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nexport const CACHE_ASSETS_NAME = 'cachedAssets';\n\nfunction isCorrectResponse(response: Response) {\n  return response.ok && response.status === 200;\n}\n\nfunction timeoutRace<T extends Promise<any>>(promise: T) {\n  return Promise.race([\n    promise,\n    pause(10000).then(() => Promise.reject())\n  ]);\n}\n\nexport async function requestCache(event: FetchEvent) {\n  try {\n    // const cache = await ctx.caches.open(CACHE_ASSETS_NAME);\n    const cache = await timeoutRace(ctx.caches.open(CACHE_ASSETS_NAME));\n    const file = await timeoutRace(cache.match(event.request, {ignoreVary: true}));\n\n    if(file && isCorrectResponse(file)) {\n      return file;\n    }\n\n    const headers: HeadersInit = {'Vary': '*'};\n    let response = await fetch(event.request, {headers});\n    if(isCorrectResponse(response)) {\n      cache.put(event.request, response.clone());\n    } else if(response.status === 304) { // possible fix for 304 in Safari\n      const url = event.request.url.replace(/\\?.+$/, '') + '?' + (Math.random() * 100000 | 0);\n      response = await fetch(url, {headers});\n      if(isCorrectResponse(response)) {\n        cache.put(event.request, response.clone());\n      }\n    }\n\n    return response;\n  } catch(err) {\n    return fetch(event.request);\n  }\n}\n","export default function noop() {}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport noop from './noop';\n\nexport interface CancellablePromise<T> extends Promise<T> {\n  resolve?: (value: T) => void,\n  reject?: (...args: any[]) => void,\n  cancel?: (reason?: any) => void,\n\n  notify?: (...args: any[]) => void,\n  notifyAll?: (...args: any[]) => void,\n  lastNotify?: any,\n  listeners?: Array<(...args: any[]) => void>,\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\n\n  isFulfilled?: boolean,\n  isRejected?: boolean\n}\n\nexport default function deferredPromise<T>() {\n  const deferredHelper: any = {\n    isFulfilled: false,\n    isRejected: false,\n\n    notify: () => {},\n    notifyAll: (...args: any[]) => {\n      deferredHelper.lastNotify = args;\n      deferredHelper.listeners.forEach((callback: any) => callback(...args));\n    },\n\n    listeners: [],\n    addNotifyListener: (callback: (...args: any[]) => void) => {\n      if(deferredHelper.lastNotify) {\n        callback(...deferredHelper.lastNotify);\n      }\n\n      deferredHelper.listeners.push(callback);\n    }\n  };\n\n  const deferred: CancellablePromise<T> = new Promise<T>((resolve, reject) => {\n    deferredHelper.resolve = (value: T) => {\n      if(deferred.isFulfilled || deferred.isRejected) return;\n\n      deferred.isFulfilled = true;\n      resolve(value);\n    };\n\n    deferredHelper.reject = (...args: any[]) => {\n      if(deferred.isRejected || deferred.isFulfilled) return;\n\n      deferred.isRejected = true;\n      reject(...args);\n    };\n  });\n\n  // @ts-ignore\n  /* deferred.then = (resolve: (value: T) => any, reject: (...args: any[]) => any) => {\n    const n = deferredPromise<ReturnType<typeof resolve>>();\n\n  }; */\n\n  deferred.catch(noop).finally(() => {\n    deferred.notify = deferred.notifyAll = deferred.lastNotify = null;\n    deferred.listeners.length = 0;\n\n    if(deferred.cancel) {\n      deferred.cancel = noop;\n    }\n  });\n\n  Object.assign(deferred, deferredHelper);\n\n  return deferred;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport blobSafeMimeType from './blobSafeMimeType';\n\nexport default function blobConstruct<T extends Uint8Array | string>(blobParts: Array<T> | T, mimeType: string = ''): Blob {\n  if(!Array.isArray(blobParts)) {\n    blobParts = [blobParts];\n  }\n\n  const safeMimeType = blobSafeMimeType(mimeType);\n  const blob = new Blob(blobParts, {type: safeMimeType});\n  return blob;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\n// https://www.iana.org/assignments/media-types/media-types.xhtml\nexport default function blobSafeMimeType(mimeType: string) {\n  if([\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'image/svg+xml',\n    'image/webp',\n    'image/bmp',\n    'video/mp4',\n    'video/webm',\n    'video/quicktime',\n    'audio/ogg',\n    'audio/mpeg',\n    'audio/mp4',\n    'audio/wav', // though it is not in list\n    'application/json',\n    'application/pdf'\n  ].indexOf(mimeType) === -1) {\n    return 'application/octet-stream';\n  }\n\n  return mimeType;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport blobConstruct from '../../helpers/blob/blobConstruct';\nimport StreamWriter from './streamWriter';\n\nexport default class MemoryWriter implements StreamWriter {\n  private bytes: Uint8Array;\n\n  constructor(\n    private mimeType: string,\n    private size: number,\n    private saveFileCallback?: (blob: Blob) => Promise<Blob>\n  ) {\n    this.bytes = new Uint8Array(size);\n  }\n\n  public async write(part: Uint8Array, offset: number) {\n    // sometimes file size can be bigger than the prov\n    const endOffset = offset + part.byteLength;\n    if(endOffset > this.bytes.byteLength) {\n      const newBytes = new Uint8Array(endOffset);\n      newBytes.set(this.bytes, 0);\n      this.bytes = newBytes;\n    }\n\n    this.bytes.set(part, offset);\n  };\n\n  public truncate() {\n    this.bytes = new Uint8Array();\n  }\n\n  public trim(size: number) {\n    this.bytes = this.bytes.slice(0, size);\n  }\n\n  public finalize(saveToStorage = true) {\n    const blob = blobConstruct(this.bytes, this.mimeType);\n\n    if(saveToStorage && this.saveFileCallback) {\n      this.saveFileCallback(blob);\n    }\n\n    return blob;\n  }\n\n  public getParts() {\n    return this.bytes;\n  }\n\n  public replaceParts(parts: Uint8Array) {\n    this.bytes = parts;\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from '../../config/modes';\nimport blobConstruct from '../../helpers/blob/blobConstruct';\nimport MemoryWriter from './memoryWriter';\nimport FileManager from './memoryWriter';\nimport FileStorage from './fileStorage';\nimport makeError from '../../helpers/makeError';\nimport deferredPromise from '../../helpers/cancellablePromise';\n\nexport type CacheStorageDbName = 'cachedFiles' | 'cachedStreamChunks' | 'cachedAssets';\n\nexport default class CacheStorageController implements FileStorage {\n  private static STORAGES: CacheStorageController[] = [];\n  private openDbPromise: Promise<Cache>;\n\n  private useStorage = true;\n\n  // private log: ReturnType<typeof logger> = logger('CS');\n\n  constructor(private dbName: CacheStorageDbName) {\n    if(Modes.test) {\n      this.dbName += '_test';\n    }\n\n    if(CacheStorageController.STORAGES.length) {\n      this.useStorage = CacheStorageController.STORAGES[0].useStorage;\n    }\n\n    this.openDatabase();\n    CacheStorageController.STORAGES.push(this);\n  }\n\n  private openDatabase(): Promise<Cache> {\n    return this.openDbPromise ?? (this.openDbPromise = caches.open(this.dbName));\n  }\n\n  public delete(entryName: string) {\n    return this.timeoutOperation((cache) => cache.delete('/' + entryName));\n  }\n\n  public deleteAll() {\n    return caches.delete(this.dbName);\n  }\n\n  public get(entryName: string) {\n    return this.timeoutOperation((cache) => cache.match('/' + entryName));\n  }\n\n  public save(entryName: string, response: Response) {\n    // return new Promise((resolve) => {}); // DEBUG\n    return this.timeoutOperation((cache) => cache.put('/' + entryName, response));\n  }\n\n  public getFile(fileName: string, method: 'blob' | 'json' | 'text' = 'blob'): Promise<any> {\n    // if(method === 'blob') {\n    //   return Promise.reject(makeError('NO_ENTRY_FOUND'));\n    // }\n\n    // const str = `get fileName: ${fileName}`;\n    // console.time(str);\n    return this.get(fileName).then((response) => {\n      if(!response) {\n        // console.warn('getFile:', response, fileName);\n        throw makeError('NO_ENTRY_FOUND');\n      }\n\n      const promise = response[method]();\n      // promise.then(() => {\n      //   console.timeEnd(str);\n      // });\n      return promise;\n    });\n  }\n\n  public saveFile(fileName: string, blob: Blob | Uint8Array) {\n    // return Promise.resolve(blobConstruct([blob]));\n    if(!(blob instanceof Blob)) {\n      blob = blobConstruct(blob);\n    }\n\n    const response = new Response(blob, {\n      headers: {\n        'Content-Length': '' + blob.size\n      }\n    });\n\n    return this.save(fileName, response).then(() => blob as Blob);\n  }\n\n  public timeoutOperation<T>(callback: (cache: Cache) => Promise<T>) {\n    if(!this.useStorage) {\n      return Promise.reject(makeError('STORAGE_OFFLINE'));\n    }\n\n    return new Promise<T>(async(resolve, reject) => {\n      let rejected = false;\n      const timeout = setTimeout(() => {\n        reject();\n        // console.warn('CACHESTORAGE TIMEOUT');\n        rejected = true;\n      }, 15e3);\n\n      try {\n        const cache = await this.openDatabase();\n        if(!cache) {\n          this.useStorage = false;\n          this.openDbPromise = undefined;\n          throw 'no cache?';\n        }\n\n        const res = await callback(cache);\n\n        if(rejected) return;\n        resolve(res);\n      } catch(err) {\n        reject(err);\n      }\n\n      clearTimeout(timeout);\n    });\n  }\n\n  public prepareWriting(fileName: string, fileSize: number, mimeType: string) {\n    return {\n      deferred: deferredPromise<Blob>(),\n      getWriter: () => {\n        const writer = new MemoryWriter(mimeType, fileSize, (blob) => {\n          return this.saveFile(fileName, blob).catch(() => blob);\n        });\n\n        return writer;\n      }\n    };\n  }\n\n  public static toggleStorage(enabled: boolean, clearWrite: boolean) {\n    return Promise.all(this.STORAGES.map((storage) => {\n      storage.useStorage = enabled;\n\n      if(!clearWrite) {\n        return;\n      }\n\n      if(!enabled) {\n        return storage.deleteAll();\n      }\n    }));\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAsUint8Array from '../../helpers/blob/readBlobAsUint8Array';\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\nimport debounce from '../../helpers/schedulers/debounce';\nimport {InputFileLocation} from '../../layer';\nimport CacheStorageController from '../files/cacheStorage';\nimport {DownloadOptions, MyUploadFile} from '../mtproto/apiFileManager';\nimport {getMtprotoMessagePort, log, serviceMessagePort} from './index.service';\nimport {ServiceRequestFilePartTaskPayload} from './serviceMessagePort';\nimport timeout from './timeout';\n\nconst deferredPromises: Map<MessagePort, {[taskId: string]: CancellablePromise<MyUploadFile>}> = new Map();\nconst cacheStorage = new CacheStorageController('cachedStreamChunks');\nconst CHUNK_TTL = 86400;\nconst CHUNK_CACHED_TIME_HEADER = 'Time-Cached';\nconst USE_CACHE = true;\n\nconst clearOldChunks = () => {\n  return cacheStorage.timeoutOperation((cache) => {\n    return cache.keys().then((requests) => {\n      const filtered: Map<StreamId, Request> = new Map();\n      const timestamp = Date.now() / 1000 | 0;\n      for(const request of requests) {\n        const match = request.url.match(/\\/(\\d+?)\\?/);\n        if(match && !filtered.has(match[1])) {\n          filtered.set(match[1], request);\n        }\n      }\n\n      const promises: Promise<any>[] = [];\n      for(const [id, request] of filtered) {\n        const promise = cache.match(request).then((response) => {\n          if((+response.headers.get(CHUNK_CACHED_TIME_HEADER) + CHUNK_TTL) <= timestamp) {\n            log('will delete stream chunk:', id);\n            return cache.delete(request, {ignoreSearch: true, ignoreVary: true});\n          }\n        });\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    });\n  });\n};\n\nsetInterval(clearOldChunks, 1800e3);\nsetInterval(() => {\n  const mtprotoMessagePort = getMtprotoMessagePort();\n  for(const [messagePort, promises] of deferredPromises) {\n    if(messagePort !== mtprotoMessagePort) {\n      for(const taskId in promises) {\n        const promise = promises[taskId];\n        promise.reject();\n      }\n\n      deferredPromises.delete(messagePort);\n    }\n  }\n}, 120e3);\n\ntype StreamRange = [number, number];\ntype StreamId = DocId;\nconst streams: Map<StreamId, Stream> = new Map();\nclass Stream {\n  private destroyDebounced: () => void;\n  private id: StreamId;\n  private limitPart: number;\n  private loadedOffsets: Set<number> = new Set();\n\n  constructor(private info: DownloadOptions) {\n    this.id = Stream.getId(info);\n    streams.set(this.id, this);\n\n    // ! если грузить очень большое видео чанками по 512Кб в мобильном Safari, то стрим не запустится\n    this.limitPart = info.size > (75 * 1024 * 1024) ? STREAM_CHUNK_UPPER_LIMIT : STREAM_CHUNK_MIDDLE_LIMIT;\n    this.destroyDebounced = debounce(this.destroy, 150000, false, true);\n  }\n\n  private destroy = () => {\n    streams.delete(this.id);\n  };\n\n  private async requestFilePartFromWorker(alignedOffset: number, limit: number, fromPreload = false) {\n    const payload: ServiceRequestFilePartTaskPayload = {\n      docId: this.id,\n      dcId: this.info.dcId,\n      offset: alignedOffset,\n      limit\n    };\n\n    const taskId = JSON.stringify(payload);\n\n    const mtprotoMessagePort = getMtprotoMessagePort();\n    let promises = deferredPromises.get(mtprotoMessagePort);\n    if(!promises) {\n      deferredPromises.set(mtprotoMessagePort, promises = {});\n    }\n\n    let deferred = promises[taskId];\n    if(deferred) {\n      return deferred.then((uploadFile) => uploadFile.bytes);\n    }\n\n    this.loadedOffsets.add(alignedOffset);\n\n    deferred = promises[taskId] = deferredPromise();\n\n    serviceMessagePort.invoke('requestFilePart', payload, undefined, mtprotoMessagePort)\n    .then(deferred.resolve, deferred.reject).finally(() => {\n      if(promises[taskId] === deferred) {\n        delete promises[taskId];\n\n        if(!Object.keys(promises).length) {\n          deferredPromises.delete(mtprotoMessagePort);\n        }\n      }\n    });\n\n    const bytesPromise = deferred.then((uploadFile) => uploadFile.bytes);\n\n    if(USE_CACHE) {\n      this.saveChunkToCache(bytesPromise, alignedOffset, limit);\n      !fromPreload && this.preloadChunks(alignedOffset, alignedOffset + (this.limitPart * 15));\n    }\n\n    return bytesPromise;\n  }\n\n  private requestFilePartFromCache(alignedOffset: number, limit: number, fromPreload?: boolean) {\n    if(!USE_CACHE) {\n      return Promise.resolve();\n    }\n\n    const key = this.getChunkKey(alignedOffset, limit);\n    return cacheStorage.getFile(key).then((blob: Blob) => {\n      return fromPreload ? new Uint8Array() : readBlobAsUint8Array(blob);\n    }, (error: ApiError) => {\n      if(error.type === 'NO_ENTRY_FOUND') {\n        return;\n      }\n    });\n  }\n\n  private requestFilePart(alignedOffset: number, limit: number, fromPreload?: boolean) {\n    return this.requestFilePartFromCache(alignedOffset, limit, fromPreload).then((bytes) => {\n      return bytes || this.requestFilePartFromWorker(alignedOffset, limit, fromPreload);\n    });\n  }\n\n  private saveChunkToCache(deferred: Promise<Uint8Array>, alignedOffset: number, limit: number) {\n    return deferred.then((bytes) => {\n      const key = this.getChunkKey(alignedOffset, limit);\n      const response = new Response(bytes, {\n        headers: {\n          'Content-Length': '' + bytes.length,\n          'Content-Type': 'application/octet-stream',\n          [CHUNK_CACHED_TIME_HEADER]: '' + (Date.now() / 1000 | 0)\n        }\n      });\n\n      return cacheStorage.save(key, response);\n    });\n  }\n\n  private preloadChunk(offset: number) {\n    if(this.loadedOffsets.has(offset)) {\n      return;\n    }\n\n    this.loadedOffsets.add(offset);\n    this.requestFilePart(offset, this.limitPart, true);\n  }\n\n  private preloadChunks(offset: number, end: number) {\n    if(end > this.info.size) {\n      end = this.info.size;\n    }\n\n    if(!offset) { // load last chunk for bounds\n      this.preloadChunk(alignOffset(offset, this.limitPart));\n    } else { // don't preload next chunks before the start\n      for(; offset < end; offset += this.limitPart) {\n        this.preloadChunk(offset);\n      }\n    }\n  }\n\n  public requestRange(range: StreamRange) {\n    this.destroyDebounced();\n\n    const possibleResponse = responseForSafariFirstRange(range, this.info.mimeType, this.info.size);\n    if(possibleResponse) {\n      return possibleResponse;\n    }\n\n    let [offset, end] = range;\n\n    /* if(info.size > limitPart && isSafari && offset === limitPart) {\n      //end = info.size - 1;\n      //offset = info.size - 1 - limitPart;\n      offset = info.size - (info.size % limitPart);\n    } */\n\n    const limit = end && end < this.limitPart ? alignLimit(end - offset + 1) : this.limitPart;\n    const alignedOffset = alignOffset(offset, limit);\n\n    if(!end) {\n      end = Math.min(offset + limit, this.info.size - 1);\n    }\n\n    return this.requestFilePart(alignedOffset, limit).then((ab) => {\n      // log.debug('[stream] requestFilePart result:', result);\n\n      // if(isSafari) {\n      if(offset !== alignedOffset || end !== (alignedOffset + limit)) {\n        ab = ab.slice(offset - alignedOffset, end - alignedOffset + 1);\n      }\n\n      const headers: Record<string, string> = {\n        'Accept-Ranges': 'bytes',\n        'Content-Range': `bytes ${offset}-${offset + ab.byteLength - 1}/${this.info.size || '*'}`,\n        'Content-Length': `${ab.byteLength}`\n      };\n\n      if(this.info.mimeType) {\n        headers['Content-Type'] = this.info.mimeType;\n      }\n\n      // simulate slow connection\n      // setTimeout(() => {\n      return new Response(ab, {\n        status: 206,\n        statusText: 'Partial Content',\n        headers\n      });\n      // }, 2.5e3);\n    });\n  }\n\n  private getChunkKey(alignedOffset: number, limit: number) {\n    return this.id + '?offset=' + alignedOffset + '&limit=' + limit;\n  }\n\n  public static get(info: DownloadOptions) {\n    return streams.get(this.getId(info)) ?? new Stream(info);\n  }\n\n  private static getId(info: DownloadOptions) {\n    return (info.location as InputFileLocation.inputDocumentFileLocation).id;\n  }\n}\n\nexport default function onStreamFetch(event: FetchEvent, params: string) {\n  const range = parseRange(event.request.headers.get('Range'));\n  const info: DownloadOptions = JSON.parse(decodeURIComponent(params));\n  const stream = Stream.get(info);\n\n  // log.debug('[stream]', url, offset, end);\n\n  event.respondWith(Promise.race([\n    timeout(45 * 1000),\n    stream.requestRange(range)\n  ]));\n}\n\nfunction responseForSafariFirstRange(range: StreamRange, mimeType: string, size: number): Response {\n  if(range[0] === 0 && range[1] === 1) {\n    return new Response(new Uint8Array(2).buffer, {\n      status: 206,\n      statusText: 'Partial Content',\n      headers: {\n        'Accept-Ranges': 'bytes',\n        'Content-Range': `bytes 0-1/${size || '*'}`,\n        'Content-Length': '2',\n        'Content-Type': mimeType || 'video/mp4'\n      }\n    });\n  }\n\n  return null;\n}\n\n/* const STREAM_CHUNK_UPPER_LIMIT = 256 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 256 * 4; */\n/* const STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 1024 * 4; */\nconst STREAM_CHUNK_MIDDLE_LIMIT = 512 * 1024;\nconst STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 512 * 4;\n\nfunction parseRange(header: string): StreamRange {\n  if(!header) return [0, 0];\n  const [, chunks] = header.split('=');\n  const ranges = chunks.split(', ');\n  const [offset, end] = ranges[0].split('-');\n\n  return [+offset, +end || 0];\n}\n\nfunction alignOffset(offset: number, base = SMALLEST_CHUNK_LIMIT) {\n  return offset - (offset % base);\n}\n\nfunction alignLimit(limit: number) {\n  return 2 ** Math.ceil(Math.log(limit) / Math.log(2));\n}\n","// * Jolly Cobra's schedulers\n\nimport ctx from '../../environment/ctx';\nimport {AnyFunction, Awaited} from '../../types';\nimport noop from '../noop';\n\nexport type DebounceReturnType<F extends AnyFunction> = {\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n  clearTimeout(): void;\n  isDebounced(): boolean;\n};\n\nexport default function debounce<F extends AnyFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n  shouldRunLast = true\n): DebounceReturnType<F> {\n  let waitingTimeout: number;\n  let waitingPromise: Promise<Awaited<ReturnType<F>>>, resolve: (result: any) => void, reject: () => void;\n  let hadNewCall = false;\n\n  const invoke = (args: Parameters<F>) => {\n    const _resolve = resolve, _reject = reject;\n    try {\n      const result = fn.apply(null, args);\n      _resolve(result);\n    } catch(err) {\n      console.error('debounce error', err);\n      // @ts-ignore\n      _reject(err);\n    }\n  };\n\n  const debounce = (...args: Parameters<F>) => {\n    if(!waitingPromise) waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\n\n    if(waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      hadNewCall = true;\n      reject();\n      waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\n    } else if(shouldRunFirst) {\n      invoke(args);\n      hadNewCall = false;\n    }\n\n    const _waitingTimeout = ctx.setTimeout(() => {\n      // will run if should run last or first but with new call\n      if(shouldRunLast && (!shouldRunFirst || hadNewCall)) {\n        invoke(args);\n      }\n\n      // if debounce was called during invoking\n      if(waitingTimeout === _waitingTimeout) {\n        waitingTimeout = waitingPromise = resolve = reject = undefined;\n        hadNewCall = false;\n      }\n    }, ms);\n\n    waitingTimeout = _waitingTimeout;\n    waitingPromise.catch(noop);\n    return waitingPromise;\n  };\n\n  debounce.clearTimeout = () => {\n    if(waitingTimeout) {\n      ctx.clearTimeout(waitingTimeout);\n      reject();\n      waitingTimeout = waitingPromise = resolve = reject = undefined;\n      hadNewCall = false;\n    }\n  };\n\n  debounce.isDebounced = () => !!waitingTimeout;\n\n  return debounce;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAsArrayBuffer from './readBlobAsArrayBuffer';\n\nexport default function readBlobAsUint8Array(blob: Blob) {\n  return readBlobAsArrayBuffer(blob).then((buffer) => new Uint8Array(buffer));\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAs from './readBlobAs';\n\nexport default function readBlobAsArrayBuffer(blob: Blob) {\n  return readBlobAs(blob, 'readAsArrayBuffer');\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// import { IS_WEB_WORKER } from \"../context\";\n\n// const id = IS_WEB_WORKER ? Math.random() * 0x1000 | 0 : 0;\nexport default function readBlobAs(blob: Blob, method: 'readAsText'): Promise<string>;\nexport default function readBlobAs(blob: Blob, method: 'readAsDataURL'): Promise<string>;\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer'): Promise<ArrayBuffer>;\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer' | 'readAsText' | 'readAsDataURL'): Promise<any> {\n  // const perf = performance.now();\n  return new Promise<any>((resolve) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', (e) => {\n      // console.log(`readBlobAs [${id}] ${method} time ${performance.now() - perf}`);\n      resolve(e.target.result);\n    });\n    reader[method](blob);\n  });\n}\n","export default function deepEqual(x: any, y: any): boolean {\n  const ok = Object.keys, tx = typeof x, ty = typeof y;\n  return x && y && tx === 'object' && tx === ty ? (\n    ok(x).length === ok(y).length &&\n      ok(x).every((key) => deepEqual(x[key], y[key]))\n  ) : (x === y);\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {Database} from '../../config/databases';\nimport Modes from '../../config/modes';\nimport makeError from '../../helpers/makeError';\nimport safeAssign from '../../helpers/object/safeAssign';\nimport {logger} from '../logger';\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex\n */\nexport type IDBIndex = {\n  indexName: string,\n  keyPath: string,\n  objectParameters: IDBIndexParameters\n};\n\nexport type IDBStore = {\n  name: string,\n  indexes?: IDBIndex[]\n};\n\nexport type IDBOptions = {\n  name?: string,\n  storeName: string,\n  stores?: IDBStore[],\n  version?: number\n};\n\nconst DEBUG = false;\n\nexport class IDB {\n  private static INSTANCES: IDB[] = [];\n  private openDbPromise: Promise<IDBDatabase>;\n  private db: IDBDatabase;\n  private storageIsAvailable: boolean;\n  private log: ReturnType<typeof logger>;\n  private name: string;\n  private version: number;\n  private stores: IDBStore[];\n\n  constructor(db: Database<any>) {\n    safeAssign(this, db);\n\n    if(Modes.test) {\n      this.name += '_test';\n    }\n\n    this.storageIsAvailable = true;\n    this.log = logger(['IDB', db.name].join('-'));\n    this.log('constructor');\n\n    this.openDatabase(true);\n\n    IDB.INSTANCES.push(this);\n  }\n\n  public isAvailable() {\n    return this.storageIsAvailable;\n  }\n\n  public openDatabase(createNew = false): Promise<IDBDatabase> {\n    if(this.openDbPromise && !createNew) {\n      return this.openDbPromise;\n    }\n\n    const createIndexes = (os: IDBObjectStore, store: IDBStore) => {\n      const indexNames = Array.from(os.indexNames);\n      for(const indexName of indexNames) {\n        os.deleteIndex(indexName);\n      }\n\n      if(!store.indexes?.length) {\n        return;\n      }\n\n      for(const index of store.indexes) {\n        if(os.indexNames.contains(index.indexName)) {\n          continue;\n        }\n\n        os.createIndex(index.indexName, index.keyPath, index.objectParameters);\n      }\n    };\n\n    const createObjectStore = (db: IDBDatabase, store: IDBStore) => {\n      const os = db.createObjectStore(store.name);\n      createIndexes(os, store);\n    };\n\n    try {\n      var request = indexedDB.open(this.name, this.version);\n\n      if(!request) {\n        return Promise.reject();\n      }\n    } catch(error) {\n      this.log.error('error opening db', (error as Error).message);\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    let finished = false;\n    setTimeout(() => {\n      if(!finished) {\n        request.onerror(makeError('IDB_CREATE_TIMEOUT') as Event);\n      }\n    }, 3000);\n\n    return this.openDbPromise = new Promise<IDBDatabase>((resolve, reject) => {\n      request.onsuccess = (event) => {\n        finished = true;\n        const db = request.result;\n        let calledNew = false;\n\n        this.log('Opened');\n\n        db.onerror = (error) => {\n          this.storageIsAvailable = false;\n          this.log.error('Error creating/accessing IndexedDB database', error);\n          reject(error);\n        };\n\n        db.onclose = (e) => {\n          this.log.error('closed:', e);\n          !calledNew && this.openDatabase();\n        };\n\n        db.onabort = (e) => {\n          this.log.error('abort:', e);\n          const transaction = e.target as IDBTransaction;\n\n          this.openDatabase(calledNew = true);\n\n          if(transaction.onerror) {\n            transaction.onerror(e);\n          }\n\n          db.close();\n        };\n\n        db.onversionchange = (e) => {\n          this.log.error('onversionchange, lol?');\n        };\n\n        resolve(this.db = db);\n      };\n\n      request.onerror = (event) => {\n        finished = true;\n        this.storageIsAvailable = false;\n        this.log.error('Error creating/accessing IndexedDB database', event);\n        reject(event);\n      };\n\n      request.onupgradeneeded = (event) => {\n        finished = true;\n        this.log.warn('performing idb upgrade from', event.oldVersion, 'to', event.newVersion);\n\n        const target = event.target as IDBOpenDBRequest;\n        const db = target.result;\n        this.stores.forEach((store) => {\n          /* if(db.objectStoreNames.contains(store.name)) {\n            //if(event.oldVersion === 1) {\n              db.deleteObjectStore(store.name);\n            //}\n          } */\n\n          if(!db.objectStoreNames.contains(store.name)) {\n            createObjectStore(db, store);\n          } else {\n            const txn = target.transaction;\n            const os = txn.objectStore(store.name);\n            createIndexes(os, store);\n          }\n        });\n      };\n    });\n  }\n\n  public static create<T extends Database<any>>(db: T) {\n    return this.INSTANCES.find((instance) => instance.name === db.name) ?? new IDB(db);\n  }\n\n  public static closeDatabases(preserve?: IDB) {\n    this.INSTANCES.forEach((storage) => {\n      if(preserve && preserve === storage) {\n        return;\n      }\n\n      const db = storage.db;\n      if(db) {\n        db.onclose = () => {};\n        db.close();\n      }\n    });\n  }\n}\n\nexport default class IDBStorage<T extends Database<any>, StoreName extends string = T['stores'][0]['name']> {\n  private log: ReturnType<typeof logger>;\n  private storeName: T['stores'][0]['name'];\n  private idb: IDB;\n\n  constructor(db: T, storeName: typeof db['stores'][0]['name']) {\n    this.storeName = storeName;\n    this.log = logger(['IDB', db.name, storeName].join('-'));\n    this.idb = IDB.create(db);\n  }\n\n  /**\n   * ! WARNING ! function requires at least one opened connection\n   */\n  /* public static clearObjectStores() {\n    const storage = this.STORAGES[0];\n    this.closeDatabases(storage);\n\n    const names = Array.from(storage.db.objectStoreNames);\n    const promises = names.map((name) => storage.clear(name));\n    return Promise.all(promises);\n  } */\n\n  /* public static deleteDatabase() {\n    this.closeDatabases();\n\n    const storages = this.STORAGES;\n    const dbNames = Array.from(new Set(storages.map((storage) => storage.name)));\n    const promises = dbNames.map((dbName) => {\n      return new Promise<void>((resolve, reject) => {\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\n\n        deleteRequest.onerror = () => {\n          reject();\n        };\n\n        deleteRequest.onsuccess = () => {\n          resolve();\n        };\n      });\n    });\n\n    return Promise.all(promises);\n  } */\n\n  public delete(entryName: string | string[], storeName?: StoreName): Promise<void> {\n    // return Promise.resolve();\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      entryName = [].concat(entryName);\n    }\n\n    return this.getObjectStore('readwrite', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName) => objectStore.delete(entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'delete: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  public clear(storeName?: StoreName): Promise<void> {\n    return this.getObjectStore('readwrite', (objectStore) => objectStore.clear(), DEBUG ? 'clear' : '', storeName);\n  }\n\n  public save(entryName: string | string[], value: any | any[], storeName?: StoreName) {\n    // const handleError = (error: Error) => {\n    //   this.log.error('save: transaction error:', entryName, value, db, error, error && error.name);\n    //   if((!error || error.name === 'InvalidStateError')/*  && false */) {\n    //     setTimeout(() => {\n    //       this.save(entryName, value);\n    //     }, 2e3);\n    //   } else {\n    //     //console.error('IndexedDB saveFile transaction error:', error, error && error.name);\n    //   }\n    // };\n\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      entryName = [].concat(entryName);\n      value = [].concat(value);\n    }\n\n    return this.getObjectStore('readwrite', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName, idx) => objectStore.put(value[idx], entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'save: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  // public saveFile(fileName: string, blob: Blob | Uint8Array) {\n  //   //return Promise.resolve(blobConstruct([blob]));\n  //   if(!(blob instanceof Blob)) {\n  //     blob = blobConstruct(blob);\n  //   }\n\n  //   return this.save(fileName, blob);\n  // }\n\n  /* public saveFileBase64(db: IDBDatabase, fileName: string, blob: Blob | any): Promise<Blob> {\n    if(this.getBlobSize(blob) > 10 * 1024 * 1024) {\n      return Promise.reject();\n    }\n\n    if(!(blob instanceof Blob)) {\n      var safeMimeType = blobSafeMimeType(blob.type || 'image/jpeg');\n      var address = 'data:' + safeMimeType + ';base64,' + bytesToBase64(blob);\n      return this.storagePutB64String(db, fileName, address).then(() => {\n        return blob;\n      });\n    }\n\n    try {\n      var reader = new FileReader();\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    let promise = new Promise<Blob>((resolve, reject) => {\n      reader.onloadend = () => {\n        this.storagePutB64String(db, fileName, reader.result as string).then(() => {\n          resolve(blob);\n        }, reject);\n      }\n\n      reader.onerror = reject;\n    });\n\n\n    try {\n      reader.readAsDataURL(blob);\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    return promise;\n  }\n\n  public storagePutB64String(db: IDBDatabase, fileName: string, b64string: string) {\n    try {\n      var objectStore = db.transaction([this.storeName], 'readwrite')\n        .objectStore(this.storeName);\n      var request = objectStore.put(b64string, fileName);\n    } catch(error) {\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = function(event) {\n        resolve();\n      };\n\n      request.onerror = reject;\n    });\n  }\n\n  public getBlobSize(blob: any) {\n    return blob.size || blob.byteLength || blob.length;\n  } */\n\n  public get<T>(entryName: string[], storeName?: StoreName): Promise<T[]>;\n  public get<T>(entryName: string, storeName?: StoreName): Promise<T>;\n  public get<T>(entryName: string | string[], storeName?: StoreName): Promise<T> | Promise<T[]> {\n    // return Promise.reject();\n\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      if(!entryName) {\n        return undefined;\n      }\n\n      entryName = [].concat(entryName);\n    } else if(!entryName.length) {\n      return Promise.resolve([]) as any;\n    }\n\n    return this.getObjectStore<T>('readonly', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName) => objectStore.get(entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'get: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  private getObjectStore<T>(\n    mode: IDBTransactionMode,\n    callback: (objectStore: IDBObjectStore) => IDBRequest | IDBRequest[],\n    log?: string,\n    storeName = this.storeName\n  ) {\n    let perf: number;\n\n    if(log) {\n      perf = performance.now();\n      this.log(log + ': start');\n    }\n\n    return this.idb.openDatabase().then((db) => {\n      return new Promise<T>((resolve, reject) => {\n        /* if(mode === 'readwrite') {\n          return;\n        } */\n\n        const transaction = db.transaction([storeName], mode);\n\n        const onError = () => {\n          clearTimeout(timeout);\n          reject(transaction.error);\n        };\n\n        // let resolved = false;\n        const onComplete = (/* what: string */) => {\n          clearTimeout(timeout);\n\n          if(log) {\n            this.log(log + ': end', performance.now() - perf/* , what */);\n          }\n\n          // if(resolved) {\n          //   return;\n          // }\n\n          // resolved = true;\n          const results = requests.map((r) => r.result);\n          resolve(isArray ? results : results[0]);\n        };\n\n        transaction.onerror = onError;\n\n        // * have to wait while clearing or setting something\n        const waitForTransactionComplete = mode === 'readwrite';\n        if(waitForTransactionComplete) {\n          transaction.oncomplete = () => onComplete(/* 'transaction' */);\n        }\n\n        const timeout = setTimeout(() => {\n          this.log.error('transaction not finished', transaction, log);\n        }, 10000);\n\n        /* transaction.addEventListener('abort', (e) => {\n          //handleError();\n          this.log.error('IndexedDB: transaction abort!', transaction.error);\n        }); */\n\n        const callbackResult = callback(transaction.objectStore(storeName));\n\n        const isArray = Array.isArray(callbackResult);\n        const requests: IDBRequest[] = isArray ? callbackResult : [].concat(callbackResult) as any;\n\n        if(waitForTransactionComplete) {\n          return;\n        }\n\n        const length = requests.length;\n        let left = length;\n\n        const onRequestFinished = () => {\n          if(transaction.error) {\n            return;\n          }\n\n          if(!--left) {\n            onComplete(/* 'requests' */);\n          }\n        };\n\n        for(let i = 0; i < length; ++i) {\n          const request = requests[i];\n          request.onerror = onError;\n          request.onsuccess = onRequestFinished;\n        }\n      });\n    });\n  }\n\n  public getAll<T>(storeName?: StoreName): Promise<T[]> {\n    return this.getObjectStore<T[]>('readonly', (objectStore) => objectStore.getAll(), DEBUG ? 'getAll' : '', storeName);\n  }\n\n  /* public getAllKeys(): Promise<Array<string>> {\n    console.time('getAllEntries');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.getAllKeys();\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var result = event.target.result;\n          resolve(result);\n          console.timeEnd('getAllEntries');\n        }\n\n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public isFileExists(fileName: string): Promise<boolean> {\n    console.time('isFileExists');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.openCursor(fileName);\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var cursor = event.target.result;\n          resolve(!!cursor);\n          console.timeEnd('isFileExists');\n        }\n\n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public getFileWriter(fileName: string, mimeType: string) {\n    var fakeWriter = FileManager.getFakeFileWriter(mimeType, (blob) => {\n      return this.saveFile(fileName, blob);\n    });\n\n    return Promise.resolve(fakeWriter);\n  } */\n}\n","export default function safeAssign<T>(object: T, fromObject: any) {\n  if(fromObject) {\n    for(const i in fromObject) {\n      if(fromObject[i] !== undefined) {\n        // @ts-ignore\n        object[i] = fromObject[i];\n      }\n    }\n  }\n\n  return object;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {Database} from '../../config/databases';\nimport DATABASE_STATE from '../../config/databases/state';\nimport {NOTIFICATION_BADGE_PATH, NOTIFICATION_ICON_PATH} from '../../config/notifications';\nimport {IS_FIREFOX} from '../../environment/userAgent';\nimport deepEqual from '../../helpers/object/deepEqual';\nimport IDBStorage from '../files/idb';\nimport {log, serviceMessagePort} from './index.service';\nimport {ServicePushPingTaskPayload} from './serviceMessagePort';\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nconst defaultBaseUrl = location.protocol + '//' + location.hostname + location.pathname.split('/').slice(0, -1).join('/') + '/';\n\n// as in webPushApiManager.ts\nconst PING_PUSH_TIMEOUT = 10000 + 1500;\nlet lastPingTime = 0;\nlet localNotificationsAvailable = true;\n\nexport type PushNotificationObject = {\n  loc_key: string,\n  loc_args: string[],\n  // user_id: number, // should be number\n  custom: {\n    channel_id?: string, // should be number\n    chat_id?: string, // should be number\n    from_id?: string, // should be number\n    msg_id: string,\n    peerId?: string, // should be number\n    silent?: string // can be '1'\n  },\n  sound?: string,\n  random_id: number,\n  badge?: string, // should be number\n  description: string,\n  mute: string, // should be number\n  title: string,\n  message?: string,\n} & {\n  action?: 'mute1d' | 'push_settings', // will be set before postMessage to main thread\n};\n\nclass SomethingGetter<T extends Database<any>, Storage extends Record<string, any>> {\n  private cache: Partial<Storage> = {};\n  private storage: IDBStorage<T>;\n\n  constructor(\n    db: T,\n    storeName: typeof db['stores'][number]['name'],\n    private defaults: {\n      [Property in keyof Storage]: ((value: Storage[Property]) => Storage[Property]) | Storage[Property]\n    }\n  ) {\n    this.storage = new IDBStorage<T>(db, storeName);\n  }\n\n  private getDefault<T extends keyof Storage>(key: T) {\n    const callback = this.defaults[key];\n    return typeof(callback) === 'function' ? callback() : callback;\n  }\n\n  public get<T extends keyof Storage>(key: T) {\n    if(this.cache.hasOwnProperty(key)) {\n      return this.cache[key];\n    }\n\n    const promise = this.storage.get(key as string) as Promise<Storage[T]>;\n    return promise.then((value) => value, () => undefined as Storage[T]).then((value) => {\n      if(this.cache.hasOwnProperty(key)) {\n        return this.cache[key];\n      }\n\n      value ??= this.getDefault(key);\n\n      return this.cache[key] = value;\n    });\n  }\n\n  public getCached<T extends keyof Storage>(key: T) {\n    const value = this.get(key);\n    if(value instanceof Promise) {\n      throw 'no property';\n    }\n\n    return value;\n  }\n\n  public async set<T extends keyof Storage>(key: T, value: Storage[T]) {\n    const cached = this.cache[key] ?? this.defaults[key];\n    if(deepEqual(cached, value)) {\n      return;\n    }\n\n    this.cache[key] = value;\n\n    try {\n      this.storage.save(key as string, value);\n    } catch(err) {\n\n    }\n  }\n}\n\ntype PushStorage = {\n  push_mute_until: number,\n  push_lang: Partial<ServicePushPingTaskPayload['lang']>\n  push_settings: Partial<ServicePushPingTaskPayload['settings']>\n};\n\nconst defaults: PushStorage = {\n  push_mute_until: 0,\n  push_lang: {\n    push_message_nopreview: 'You have a new message',\n    push_action_mute1d: 'Mute for 24H',\n    push_action_settings: 'Settings'\n  },\n  push_settings: {}\n};\n\nconst getter = new SomethingGetter<typeof DATABASE_STATE, PushStorage>(DATABASE_STATE, 'session', defaults);\n\n// fill cache\nfor(const i in defaults) {\n  getter.get(i as keyof PushStorage);\n}\n\nctx.addEventListener('push', (event) => {\n  const obj: PushNotificationObject = event.data.json();\n  log('push', {...obj});\n\n  try {\n    const [muteUntil, settings, lang] = [\n      getter.getCached('push_mute_until'),\n      getter.getCached('push_settings'),\n      getter.getCached('push_lang')\n    ];\n\n    const nowTime = Date.now();\n    if(\n      userInvisibleIsSupported() &&\n      muteUntil &&\n      nowTime < muteUntil\n    ) {\n      throw `supress notification because mute for ${Math.ceil((muteUntil - nowTime) / 60000)} min`;\n    }\n\n    const hasActiveWindows = (Date.now() - lastPingTime) <= PING_PUSH_TIMEOUT && localNotificationsAvailable;\n    if(hasActiveWindows) {\n      throw 'supress notification because some instance is alive';\n    }\n\n    const notificationPromise = fireNotification(obj, settings, lang);\n    event.waitUntil(notificationPromise);\n  } catch(err) {\n    log(err);\n\n    // const tag = 'fix';\n    // const notificationPromise = ctx.registration.showNotification('Telegram', {tag});\n\n    // notificationPromise.then(() => {\n    //   closeAllNotifications(tag);\n    // });\n\n    // event.waitUntil(notificationPromise);\n  }\n});\n\nctx.addEventListener('notificationclick', (event) => {\n  const notification = event.notification;\n  log('on notification click', notification);\n  notification.close();\n\n  const action = event.action as PushNotificationObject['action'];\n  if(action === 'mute1d' && userInvisibleIsSupported()) {\n    log('[SW] mute for 1d');\n    getter.set('push_mute_until', Date.now() + 86400e3);\n    return;\n  }\n\n  const data: PushNotificationObject = notification.data;\n  if(!data) {\n    return;\n  }\n\n  const promise = ctx.clients.matchAll({\n    type: 'window'\n  }).then((clientList) => {\n    data.action = action;\n    pendingNotification = data;\n    for(let i = 0; i < clientList.length; ++i) {\n      const client = clientList[i];\n      if('focus' in client) {\n        client.focus();\n        serviceMessagePort.invokeVoid('pushClick', pendingNotification, client);\n        pendingNotification = undefined;\n        return;\n      }\n    }\n\n    if(ctx.clients.openWindow) {\n      return Promise.resolve(getter.get('push_settings')).then((settings) => {\n        return ctx.clients.openWindow(settings.baseUrl || defaultBaseUrl);\n      });\n    }\n  }).catch((error) => {\n    log.error('Clients.matchAll error', error);\n  })\n\n  event.waitUntil(promise);\n});\n\nctx.addEventListener('notificationclose', onCloseNotification);\n\nconst notifications: Set<Notification> = new Set();\nlet pendingNotification: PushNotificationObject;\nfunction pushToNotifications(notification: Notification) {\n  if(!notifications.has(notification)) {\n    notifications.add(notification);\n    // @ts-ignore\n    notification.onclose = onCloseNotification;\n  }\n}\n\nfunction onCloseNotification(event: NotificationEvent) {\n  removeFromNotifications(event.notification)\n}\n\nfunction removeFromNotifications(notification: Notification) {\n  notifications.delete(notification);\n}\n\nexport function closeAllNotifications(tag?: string) {\n  for(const notification of notifications) {\n    try {\n      if(tag && notification.tag !== tag) {\n        continue;\n      }\n\n      notification.close();\n      notifications.delete(notification);\n    } catch(e) {}\n  }\n\n  let promise: Promise<void>;\n  if('getNotifications' in ctx.registration) {\n    promise = ctx.registration.getNotifications({tag}).then((notifications) => {\n      for(let i = 0, len = notifications.length; i < len; ++i) {\n        try {\n          notifications[i].close();\n        } catch(e) {}\n      }\n    }).catch((error) => {\n      log.error('Offline register SW error', error);\n    });\n  } else {\n    promise = Promise.resolve();\n  }\n\n  return promise;\n}\n\nfunction userInvisibleIsSupported() {\n  return IS_FIREFOX;\n}\n\nfunction fireNotification(obj: PushNotificationObject, settings: PushStorage['push_settings'], lang: PushStorage['push_lang']) {\n  let title = obj.title || 'Telegram';\n  let body = obj.description || '';\n  let peerId: string;\n\n  if(obj.custom) {\n    if(obj.custom.channel_id) {\n      peerId = '' + -obj.custom.channel_id;\n    } else if(obj.custom.chat_id) {\n      peerId = '' + -obj.custom.chat_id;\n    } else {\n      peerId = obj.custom.from_id || '';\n    }\n  }\n\n  obj.custom.peerId = '' + peerId;\n  let tag = 'peer' + peerId;\n\n  const messageKey = peerId + '_' + obj.custom.msg_id;\n  if(ignoreMessages.has(messageKey)) {\n    const error = 'ignoring push';\n    log.warn(error, obj);\n    ignoreMessages.delete(messageKey);\n    throw error;\n  }\n\n  if(settings?.nopreview) {\n    title = 'Telegram';\n    body = lang.push_message_nopreview;\n    tag = 'unknown_peer';\n  }\n\n  const actions: (Omit<NotificationAction, 'action'> & {action: PushNotificationObject['action']})[] = [{\n    action: 'mute1d',\n    title: lang.push_action_mute1d\n  }/* , {\n    action: 'push_settings',\n    title: lang.push_action_settings || 'Settings'\n  } */];\n\n  const notificationOptions: NotificationOptions = {\n    body,\n    icon: NOTIFICATION_ICON_PATH,\n    tag,\n    data: obj,\n    actions,\n    badge: NOTIFICATION_BADGE_PATH,\n    silent: obj.custom.silent === '1'\n  };\n\n  log('show notify', title, body, obj, notificationOptions);\n\n  const notificationPromise = ctx.registration.showNotification(title, notificationOptions);\n\n  return notificationPromise.catch((error) => {\n    log.error('Show notification promise', error);\n  });\n}\n\nexport function onPing(payload: ServicePushPingTaskPayload, source?: MessageEventSource) {\n  lastPingTime = Date.now();\n  localNotificationsAvailable = payload.localNotifications;\n\n  if(pendingNotification && source) {\n    serviceMessagePort.invokeVoid('pushClick', pendingNotification, source);\n    pendingNotification = undefined;\n  }\n\n  if(payload.lang) {\n    getter.set('push_lang', payload.lang);\n  }\n\n  if(payload.settings) {\n    getter.set('push_settings', payload.settings);\n  }\n}\n\nconst ignoreMessages: Map<string, number> = new Map();\nexport function onShownNotification(payload: string) {\n  ignoreMessages.set(payload, Date.now());\n}\n\nsetInterval(() => {\n  const time = Date.now();\n  ignoreMessages.forEach((_time, key) => {\n    if((time - _time) > 30e3) {\n      ignoreMessages.delete(key);\n    }\n  });\n}, 30 * 60e3);\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {Database} from '.';\nimport type {IDBIndex} from '../../lib/files/idb';\n\nconst DATABASE_STATE: Database<'session' | 'stickerSets' | 'users' | 'chats' | 'messages' | 'dialogs'> = {\n  name: 'tweb',\n  version: 7,\n  stores: [{\n    name: 'session'\n  }, {\n    name: 'stickerSets'\n  }, {\n    name: 'users'\n  }, {\n    name: 'chats'\n  }, {\n    name: 'dialogs'\n    // indexes: [\n    //   ...(new Array(20 + 2).fill(0)).map((_, idx) => {\n    //     const name = `index_${idx}`;\n    //     const index: IDBIndex = {\n    //       indexName: name,\n    //       keyPath: name,\n    //       objectParameters: {}\n    //     };\n\n    //     return index\n    //   })\n    // ]\n  }, {\n    name: 'messages'\n  }]\n};\n\nexport default DATABASE_STATE;\n","export const NOTIFICATION_ICON_PATH = 'assets/img/logo_filled_rounded.png';\nexport const NOTIFICATION_BADGE_PATH = 'assets/img/logo_plain.svg'; // masked\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {WebPushApiManager} from '../mtproto/webPushApiManager';\nimport type {PushNotificationObject} from './push';\nimport type {MyUploadFile} from '../mtproto/apiFileManager';\nimport SuperMessagePort from '../mtproto/superMessagePort';\nimport {MOUNT_CLASS_TO} from '../../config/debug';\n\nexport type ServicePushPingTaskPayload = {\n  localNotifications: boolean,\n  lang: {\n    push_action_mute1d: string\n    push_action_settings: string\n    push_message_nopreview: string\n  },\n  settings: WebPushApiManager['settings']\n};\n\nexport type ServiceRequestFilePartTaskPayload = {\n  docId: DocId,\n  dcId: number,\n  offset: number,\n  limit: number\n};\n\nexport type ServiceDownloadTaskPayload = {\n  headers: any,\n  id: string\n};\n\nexport type ServiceEvent = {\n  port: (payload: void, source: MessageEventSource, event: MessageEvent) => void\n};\n\nexport default class ServiceMessagePort<Master extends boolean = false> extends SuperMessagePort<{\n  // from main thread to service worker\n  notificationsClear: () => void,\n  toggleStorages: (payload: {enabled: boolean, clearWrite: boolean}) => void,\n  pushPing: (payload: ServicePushPingTaskPayload, source: MessageEventSource, event: MessageEvent) => void,\n  hello: (payload: void, source: MessageEventSource, event: MessageEvent) => void,\n  shownNotification: (payload: string) => void,\n\n  // from mtproto worker\n  download: (payload: ServiceDownloadTaskPayload) => void,\n  downloadChunk: (payload: {id: ServiceDownloadTaskPayload['id'], chunk: Uint8Array}) => void\n  downloadFinalize: (payload: ServiceDownloadTaskPayload['id']) => void,\n  downloadCancel: (payload: ServiceDownloadTaskPayload['id']) => void\n}, {\n  // to main thread\n  pushClick: (payload: PushNotificationObject) => void,\n  hello: (payload: void, source: MessageEventSource) => void,\n  share: (payload: ShareData) => void,\n\n  // to mtproto worker\n  requestFilePart: (payload: ServiceRequestFilePartTaskPayload) => Promise<MyUploadFile> | MyUploadFile\n} & ServiceEvent, Master> {\n  constructor() {\n    super('SERVICE');\n\n    MOUNT_CLASS_TO && (MOUNT_CLASS_TO.serviceMessagePort = this);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {ServiceDownloadTaskPayload} from './serviceMessagePort';\nimport type ServiceMessagePort from './serviceMessagePort';\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\nimport makeError from '../../helpers/makeError';\nimport pause from '../../helpers/schedulers/pause';\n\ntype DownloadType = Uint8Array;\ntype DownloadItem = ServiceDownloadTaskPayload & {\n  // transformStream: TransformStream<DownloadType, DownloadType>,\n  readableStream: ReadableStream<DownloadType>,\n  // writableStream: WritableStream<DownloadType>,\n  // writer: WritableStreamDefaultWriter<DownloadType>,\n  // controller: TransformStreamDefaultController<DownloadType>,\n  controller: ReadableStreamController<Uint8Array>,\n  promise: CancellablePromise<void>,\n  // downloadPromise: Promise<void>,\n  used?: boolean\n};\nconst downloadMap: Map<string, DownloadItem> = new Map();\nconst DOWNLOAD_ERROR = makeError('UNKNOWN');\nconst DOWNLOAD_TEST = false;\n\n(self as any).downloadMap = downloadMap;\n\ntype A = Parameters<ServiceMessagePort<false>['addMultipleEventsListeners']>[0];\n\nconst events: A = {\n  download: (payload) => {\n    const {id} = payload;\n    if(downloadMap.has(id)) {\n      return Promise.reject(DOWNLOAD_ERROR);\n    }\n\n    // const y = (20 * 1024 * 1024) / payload.limitPart;\n    // const strategy = new ByteLengthQueuingStrategy({highWaterMark: y});\n    // let controller: TransformStreamDefaultController<DownloadType>;\n    const strategy = new CountQueuingStrategy({highWaterMark: 1});\n    // const transformStream = new TransformStream<DownloadType, DownloadType>(/* {\n    //   start: (_controller) => controller = _controller,\n    // },  */undefined, strategy, strategy);\n\n    // const {readable, writable} = transformStream;\n    // const writer = writable.getWriter();\n\n    const promise = deferredPromise<void>();\n    promise.then(() => {\n      setTimeout(() => {\n        downloadMap.delete(id);\n      }, 5e3);\n    }, () => {\n      downloadMap.delete(id);\n    });\n\n    // writer.closed.then(promise.resolve, promise.reject);\n\n    let controller: ReadableStreamController<any>;\n    const readable = new ReadableStream({\n      start: (_controller) => {\n        controller = _controller;\n      },\n\n      cancel: (reason) => {\n        promise.reject(DOWNLOAD_ERROR);\n      }\n    }, strategy);\n\n    // writer.closed.catch(noop).finally(() => {\n    //   log.error('closed writer');\n    //   onEnd();\n    // });\n\n    // const downloadPromise = writer.closed.catch(() => {throw DOWNLOAD_ERROR;});\n    const item: DownloadItem = {\n      ...payload,\n      // transformStream,\n      readableStream: readable,\n      // writableStream: writable,\n      // writer,\n      // downloadPromise,\n      promise,\n      controller\n    };\n\n    downloadMap.set(id, item);\n\n    // return downloadPromise;\n    return promise.catch(() => {throw DOWNLOAD_ERROR});\n  },\n\n  downloadChunk: ({id, chunk}) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return Promise.reject();\n    }\n\n    // return item.controller.enqueue(chunk);\n    // return item.writer.write(chunk);\n    // @ts-ignore\n    return item.controller.enqueue(chunk);\n  },\n\n  downloadFinalize: (id) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return Promise.reject();\n    }\n\n    item.promise.resolve();\n    // return item.controller.terminate();\n    // return item.writer.close();\n    return item.controller.close();\n  },\n\n  downloadCancel: (id) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return;\n    }\n\n    item.promise.reject();\n    // return item.controller.error();\n    // return item.writer.abort();\n    return item.controller.error();\n  }\n};\n\nexport default function handleDownload(serviceMessagePort: ServiceMessagePort<false>) {\n  serviceMessagePort.addMultipleEventsListeners(events);\n\n  return {\n    onDownloadFetch,\n    onClosedWindows: cancelAllDownloads\n  };\n}\n\nfunction onDownloadFetch(event: FetchEvent, params: string) {\n  const promise = pause(100).then(() => {\n    const item = downloadMap.get(params);\n    if(!item || (item.used && !DOWNLOAD_TEST)) {\n      return;\n    }\n\n    item.used = true;\n    const stream = item.readableStream;\n    const response = new Response(stream, {headers: item.headers});\n    return response;\n  });\n\n  event.respondWith(promise);\n}\n\nfunction cancelAllDownloads() {\n  if(downloadMap.size) {\n    for(const [id, item] of downloadMap) {\n      // item.writer.abort().catch(noop);\n      item.controller.error();\n    }\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {log, serviceMessagePort} from './index.service';\n\nconst deferred: {[id: string]: ShareData[]} = {};\n\nfunction parseFormData(formData: FormData): ShareData {\n  return {\n    files: formData.getAll('files') as File[],\n    title: formData.get('title') as string,\n    text: formData.get('text') as string,\n    url: formData.get('url') as string\n  };\n}\n\nasync function processShareEvent(formData: FormData, clientId: string) {\n  try {\n    log('share data', formData);\n    const data = parseFormData(formData);\n    (deferred[clientId] ??= []).push(data);\n  } catch(err) {\n    log.warn('something wrong with the data', err);\n  }\n};\n\nexport function checkWindowClientForDeferredShare(windowClient: WindowClient) {\n  const arr = deferred[windowClient.id];\n  if(!arr) {\n    return;\n  }\n\n  delete deferred[windowClient.id];\n\n  log('releasing share events to client:', windowClient.id, 'length:', arr.length);\n  arr.forEach((data) => {\n    serviceMessagePort.invokeVoid('share', data, windowClient);\n  });\n}\n\nexport default function onShareFetch(event: FetchEvent, params: string) {\n  const promise = event.request.formData()\n  .then((formData) => {\n    processShareEvent(formData, event.resultingClientId)\n    return Response.redirect('..');\n  });\n\n  event.respondWith(promise);\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n                 \n                                   \n         \n\nimport {logger, LogTypes} from '../logger';\nimport {CACHE_ASSETS_NAME, requestCache} from './cache';\nimport onStreamFetch from './stream';\nimport {closeAllNotifications, onPing, onShownNotification} from './push';\nimport CacheStorageController from '../files/cacheStorage';\nimport {IS_SAFARI} from '../../environment/userAgent';\nimport ServiceMessagePort from './serviceMessagePort';\nimport listenMessagePort from '../../helpers/listenMessagePort';\nimport {getWindowClients} from '../../helpers/context';\nimport {MessageSendPort} from '../mtproto/superMessagePort';\nimport handleDownload from './download';\nimport onShareFetch, {checkWindowClientForDeferredShare} from './share';\n\nexport const log = logger('SW', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn, true);\nconst ctx = self as any as ServiceWorkerGlobalScope;\n\n                  \nlet _mtprotoMessagePort: MessagePort;\nexport const getMtprotoMessagePort = () => _mtprotoMessagePort;\n\nconst sendMessagePort = (source: MessageSendPort) => {\n  const channel = new MessageChannel();\n  serviceMessagePort.attachPort(_mtprotoMessagePort = channel.port1);\n  serviceMessagePort.invokeVoid('port', undefined, source, [channel.port2]);\n};\n\nconst sendMessagePortIfNeeded = (source: MessageSendPort) => {\n  if(!connectedWindows.size && !_mtprotoMessagePort) {\n    log('sending message port for mtproto');\n    sendMessagePort(source);\n  }\n};\n\nconst onWindowConnected = (source: WindowClient) => {\n  log('window connected', source.id, 'windows before', connectedWindows.size);\n\n  if(source.frameType === 'none') {\n    log.warn('maybe a bugged Safari starting window', source.id);\n    return;\n  }\n\n  log('windows', Array.from(connectedWindows));\n  serviceMessagePort.invokeVoid('hello', undefined, source);\n  sendMessagePortIfNeeded(source);\n  connectedWindows.set(source.id, source);\n\n  checkWindowClientForDeferredShare(source);\n};\n\nexport const serviceMessagePort = new ServiceMessagePort<false>();\nserviceMessagePort.addMultipleEventsListeners({\n  notificationsClear: closeAllNotifications,\n\n  toggleStorages: ({enabled, clearWrite}) => {\n    CacheStorageController.toggleStorage(enabled, clearWrite);\n  },\n\n  pushPing: (payload, source) => {\n    onPing(payload, source);\n  },\n\n  hello: (payload, source) => {\n    onWindowConnected(source as any as WindowClient);\n  },\n\n  shownNotification: onShownNotification\n});\n\nconst {\n  onDownloadFetch,\n  onClosedWindows: onDownloadClosedWindows\n} = handleDownload(serviceMessagePort);\n\n// * service worker can be killed, so won't get 'hello' event\ngetWindowClients().then((windowClients) => {\n  log(`got ${windowClients.length} windows from the start`);\n  windowClients.forEach((windowClient) => {\n    onWindowConnected(windowClient);\n  });\n});\n\nconst connectedWindows: Map<string, WindowClient> = new Map();\n(self as any).connectedWindows = connectedWindows;\nlistenMessagePort(serviceMessagePort, undefined, (source) => {\n  log('something has disconnected', source);\n  const isWindowClient = source instanceof WindowClient;\n  if(!isWindowClient || !connectedWindows.has(source.id)) {\n    log.warn('it is not a window');\n    return;\n  }\n\n  connectedWindows.delete(source.id);\n  log('window disconnected, left', connectedWindows.size);\n  if(!connectedWindows.size) {\n    log.warn('no windows left');\n\n    if(_mtprotoMessagePort) {\n      serviceMessagePort.detachPort(_mtprotoMessagePort);\n      _mtprotoMessagePort = undefined;\n    }\n\n    onDownloadClosedWindows();\n  }\n});\n         \n\nconst onFetch = (event: FetchEvent): void => {\n               \n  if(\n    !IS_SAFARI &&\n    event.request.url.indexOf(location.origin + '/') === 0 &&\n    event.request.url.match(/\\.(js|css|jpe?g|json|wasm|png|mp3|svg|tgs|ico|woff2?|ttf|webmanifest?)(?:\\?.*)?$/)\n  ) {\n    return event.respondWith(requestCache(event));\n  }\n           \n\n  try {\n    // const [, url, scope, params] = /http[:s]+\\/\\/.*?(\\/(.*?)(?:$|\\/(.*)$))/.exec(event.request.url) || [];\n    const [scope, params] = event.request.url.split('/').slice(-2);\n\n    // log.debug('[fetch]:', event);\n\n    switch(scope) {\n      case 'stream': {\n        onStreamFetch(event, params);\n        break;\n      }\n\n      case 'download': {\n        onDownloadFetch(event, params);\n        break;\n      }\n\n      case 'share': {\n        onShareFetch(event, params);\n        break;\n      }\n\n      case 'ping': {\n        event.respondWith(new Response('pong'));\n        break;\n      }\n    }\n  } catch(err) {\n    log.error('fetch error', err);\n    event.respondWith(new Response('', {\n      status: 500,\n      statusText: 'Internal Server Error',\n      headers: {'Cache-Control': 'no-cache'}\n    }));\n  }\n};\n\nconst onChangeState = () => {\n  ctx.onfetch = onFetch;\n};\n\nctx.addEventListener('install', (event) => {\n  log('installing');\n  event.waitUntil(ctx.skipWaiting().then(() => log('skipped waiting'))); // Activate worker immediately\n});\n\nctx.addEventListener('activate', (event) => {\n  log('activating', ctx);\n  event.waitUntil(ctx.caches.delete(CACHE_ASSETS_NAME).then(() => log('cleared assets cache')));\n  event.waitUntil(ctx.clients.claim().then(() => log('claimed clients')));\n});\n\n// ctx.onerror = (error) => {\n//   log.error('error:', error);\n// };\n\n// ctx.onunhandledrejection = (error) => {\n//   log.error('onunhandledrejection:', error);\n// };\n\nctx.onoffline = ctx.ononline = onChangeState;\n\nonChangeState();\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type SuperMessagePort from '../lib/mtproto/superMessagePort';\nimport ctx from '../environment/ctx';\n\nexport default function listenMessagePort(\n  messagePort: SuperMessagePort<any, any, any>,\n  onConnect?: (source: MessageEventSource) => void,\n  onDisconnect?: (source: MessageEventSource) => void\n) {\n  const attachPort = (listenPort: any, sendPort: any) => {\n    messagePort.attachListenPort(listenPort);\n    sendPort && messagePort.attachSendPort(sendPort);\n    onConnect?.(listenPort);\n  };\n\n  messagePort.setOnPortDisconnect(onDisconnect);\n\n  if(typeof(SharedWorkerGlobalScope) !== 'undefined') {\n    (ctx as any as SharedWorkerGlobalScope).addEventListener('connect', (e) => attachPort(e.source, e.source));\n  } else if(typeof(ServiceWorkerGlobalScope) !== 'undefined') {\n    attachPort(ctx, null);\n  } else {\n    attachPort(ctx, ctx);\n  }\n}\n","export default function timeout(delay: number): Promise<Response> {\n  return new Promise(((resolve) => {\n    setTimeout(() => {\n      resolve(new Response('', {\n        status: 408,\n        statusText: 'Request timed out.'\n      }));\n    }, delay);\n  }));\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [85], () => (__webpack_require__(6350)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + \"887945ef5f43bc205112\" + \".bundle.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","(() => {\n  if (typeof __webpack_require__ !== 'undefined') {\n    var oldGetScript = __webpack_require__.u;\n    var oldLoadScript = __webpack_require__.e;\n    var queryMap = {};\n    var countMap = {};\n    var getRetryDelay = function () {\n      return 3000;\n    };\n    __webpack_require__.u = function (chunkId) {\n      var result = oldGetScript(chunkId);\n      return (\n        result +\n        (queryMap.hasOwnProperty(chunkId) ? '?' + queryMap[chunkId] : '')\n      );\n    };\n    __webpack_require__.e = function (chunkId) {\n      var result = oldLoadScript(chunkId);\n      return result.catch(function (error) {\n        var retries = countMap.hasOwnProperty(chunkId)\n          ? countMap[chunkId]\n          : 999999;\n        if (retries < 1) {\n          var realSrc = oldGetScript(chunkId);\n          error.message =\n            'Loading chunk ' +\n            chunkId +\n            ' failed after 999999 retries.\\n(' +\n            realSrc +\n            ')';\n          error.request = realSrc;\n          throw error;\n        }\n        return new Promise(function (resolve) {\n          var retryAttempt = 999999 - retries + 1;\n          setTimeout(function () {\n            var retryAttemptString = '&retry-attempt=' + retryAttempt;\n            var cacheBust = (function () {\n              return Date.now();\n            })();\n            +retryAttemptString;\n            queryMap[chunkId] = cacheBust;\n            countMap[chunkId] = retries - 1;\n            resolve(__webpack_require__.e(chunkId));\n          }, getRetryDelay(retryAttempt));\n        });\n      });\n    };\n  }\n})();\n","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t670: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = this[\"webpackChunktweb\"] = this[\"webpackChunktweb\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","DEBUG","MOUNT_CLASS_TO","window","self","USER_AGENT","navigator","userAgent","IS_SAFARI","search","toLowerCase","indexOf","test","vendor","platform","maxTouchPoints","match","IS_FIREFOX","undefined","IS_SERVICE_WORKER","ServiceWorkerGlobalScope","IS_WEB_WORKER","WorkerGlobalScope","IS_WORKER","getWindowClients","clients","matchAll","includeUncontrolled","type","postMessage","listener","args","err","console","error","notifyServiceWorker","all","then","listeners","length","slice","forEach","bind","LogTypes","LOG_LEVELS","None","Error","Warn","Log","Debug","STYLES_SUPPORTED","LOGGER_STYLES","methods","logger","prefix","ignoreDebugReset","style","originalPrefix","originalStyle","log","method","logType","setPrefix","newPrefix","setLevel","level","reduce","acc","v","bindPrefix","pause","ms","Promise","resolve","setTimeout","ctx","CACHE_ASSETS_NAME","isCorrectResponse","response","ok","status","timeoutRace","promise","race","reject","noop","deferredPromise","deferredHelper","isFulfilled","isRejected","notify","notifyAll","lastNotify","callback","addNotifyListener","push","value","catch","finally","cancel","Object","assign","blobConstruct","blobParts","mimeType","Array","isArray","safeMimeType","blobSafeMimeType","Blob","MemoryWriter","constructor","size","saveFileCallback","this","bytes","Uint8Array","write","part","offset","endOffset","byteLength","newBytes","set","truncate","trim","finalize","saveToStorage","blob","getParts","replaceParts","parts","CacheStorageController","dbName","useStorage","STORAGES","openDatabase","openDbPromise","caches","open","delete","entryName","timeoutOperation","cache","deleteAll","get","save","put","getFile","fileName","makeError","saveFile","Response","headers","rejected","timeout","res","clearTimeout","prepareWriting","fileSize","getWriter","static","enabled","clearWrite","map","storage","deferredPromises","Map","cacheStorage","CHUNK_CACHED_TIME_HEADER","setInterval","keys","requests","filtered","timestamp","Date","now","request","url","has","promises","id","ignoreSearch","ignoreVary","mtprotoMessagePort","getMtprotoMessagePort","messagePort","taskId","streams","Stream","info","loadedOffsets","Set","destroy","getId","limitPart","STREAM_CHUNK_UPPER_LIMIT","STREAM_CHUNK_MIDDLE_LIMIT","destroyDebounced","fn","shouldRunFirst","shouldRunLast","waitingTimeout","waitingPromise","hadNewCall","invoke","_resolve","_reject","apply","debounce","_waitingTimeout","isDebounced","requestFilePartFromWorker","alignedOffset","limit","fromPreload","payload","docId","dcId","JSON","stringify","uploadFile","add","serviceMessagePort","bytesPromise","saveChunkToCache","preloadChunks","requestFilePartFromCache","key","getChunkKey","reader","FileReader","addEventListener","e","target","result","readBlobAs","readBlobAsArrayBuffer","buffer","readBlobAsUint8Array","requestFilePart","preloadChunk","end","alignOffset","requestRange","range","possibleResponse","statusText","responseForSafariFirstRange","Math","ceil","alignLimit","min","ab","location","base","deepEqual","x","y","tx","every","IDB","db","object","fromObject","i","safeAssign","name","storageIsAvailable","join","INSTANCES","isAvailable","createNew","createIndexes","os","store","indexNames","from","indexName","deleteIndex","indexes","index","contains","createIndex","keyPath","objectParameters","indexedDB","version","message","finished","onerror","onsuccess","event","calledNew","onclose","onabort","transaction","close","onversionchange","onupgradeneeded","warn","oldVersion","newVersion","stores","objectStoreNames","objectStore","createObjectStore","find","instance","preserve","IDBStorage","storeName","idb","create","concat","getObjectStore","clear","idx","mode","perf","performance","onError","onComplete","results","r","waitForTransactionComplete","oncomplete","callbackResult","left","onRequestFinished","getAll","defaultBaseUrl","protocol","hostname","pathname","split","lastPingTime","localNotificationsAvailable","defaults","push_mute_until","push_lang","push_message_nopreview","push_action_mute1d","push_action_settings","push_settings","getter","getDefault","hasOwnProperty","getCached","obj","data","json","muteUntil","settings","lang","nowTime","userInvisibleIsSupported","notificationPromise","peerId","title","body","description","custom","channel_id","chat_id","from_id","tag","messageKey","msg_id","ignoreMessages","nopreview","notificationOptions","icon","actions","action","badge","silent","registration","showNotification","fireNotification","waitUntil","notification","clientList","pendingNotification","client","focus","invokeVoid","openWindow","baseUrl","notifications","time","_time","ServiceMessagePort","super","downloadMap","DOWNLOAD_ERROR","events","download","strategy","CountQueuingStrategy","highWaterMark","controller","readable","ReadableStream","start","_controller","reason","item","readableStream","downloadChunk","chunk","enqueue","downloadFinalize","downloadCancel","onDownloadFetch","params","used","stream","respondWith","cancelAllDownloads","onShareFetch","formData","clientId","files","text","parseFormData","processShareEvent","resultingClientId","redirect","_mtprotoMessagePort","onWindowConnected","source","connectedWindows","frameType","channel","MessageChannel","attachPort","port1","port2","sendMessagePort","sendMessagePortIfNeeded","windowClient","arr","checkWindowClientForDeferredShare","addMultipleEventsListeners","notificationsClear","getNotifications","len","toggleStorages","toggleStorage","pushPing","localNotifications","onPing","hello","shownNotification","onClosedWindows","onDownloadClosedWindows","handleDownload","windowClients","onConnect","onDisconnect","listenPort","sendPort","attachListenPort","attachSendPort","setOnPortDisconnect","WindowClient","detachPort","listenMessagePort","onFetch","origin","file","fetch","clone","replace","random","requestCache","scope","header","chunks","ranges","parseRange","parse","decodeURIComponent","onStreamFetch","onChangeState","onfetch","skipWaiting","claim","onoffline","ononline","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","chunkIds","priority","notFulfilled","Infinity","fulfilled","j","splice","d","definition","o","defineProperty","enumerable","f","chunkId","u","miniCssF","g","globalThis","Function","prop","prototype","call","scriptUrl","importScripts","document","currentScript","src","scripts","getElementsByTagName","p","oldGetScript","oldLoadScript","queryMap","countMap","retries","realSrc","cacheBust","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","pop"],"sourceRoot":""}