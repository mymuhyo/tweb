{"version":3,"file":"npm.iobuffer.8fe11aa09121a6fd9200.chunk.js","mappings":"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","sources":["webpack://tweb/./node_modules/iobuffer/lib-esm/text.browser.js","webpack://tweb/./node_modules/iobuffer/lib-esm/IOBuffer.js","webpack://tweb/./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js"],"sourcesContent":["// eslint-disable-next-line import/no-unassigned-import\nimport './text-encoding-polyfill';\nexport function decode(bytes, encoding = 'utf8') {\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(bytes);\n}\nconst encoder = new TextEncoder();\nexport function encode(str) {\n    return encoder.encode(str);\n}\n//# sourceMappingURL=text.browser.js.map","import { decode, encode } from './text';\nconst defaultByteLength = 1024 * 8;\nconst hostBigEndian = (() => {\n    const array = new Uint8Array(4);\n    const view = new Uint32Array(array.buffer);\n    return !((view[0] = 1) & array[0]);\n})();\nconst typedArrays = {\n    int8: globalThis.Int8Array,\n    uint8: globalThis.Uint8Array,\n    int16: globalThis.Int16Array,\n    uint16: globalThis.Uint16Array,\n    int32: globalThis.Int32Array,\n    uint32: globalThis.Uint32Array,\n    uint64: globalThis.BigUint64Array,\n    int64: globalThis.BigInt64Array,\n    float32: globalThis.Float32Array,\n    float64: globalThis.Float64Array,\n};\nexport class IOBuffer {\n    /**\n     * @param data - The data to construct the IOBuffer with.\n     * If data is a number, it will be the new buffer's length<br>\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n     * @param options\n     */\n    constructor(data = defaultByteLength, options = {}) {\n        let dataIsGiven = false;\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        }\n        else {\n            dataIsGiven = true;\n            this.lastWrittenByte = data.byteLength;\n        }\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        const byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this.lastWrittenByte = byteLength;\n        }\n        else {\n            this.lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more\n     * bytes after the offset.\n     * @param byteLength - The needed memory in bytes.\n     * @returns `true` if there is sufficient space and `false` otherwise.\n     */\n    available(byteLength = 1) {\n        return this.offset + byteLength <= this.length;\n    }\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte\n     * values.\n     * @returns `true` if little-endian mode is used, `false` otherwise.\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n    /**\n     * Set little-endian mode for reading and writing multi-byte values.\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values.\n     * @returns `true` if big-endian mode is used, `false` otherwise.\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values.\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes forward.\n     * @param n - Number of bytes to skip.\n     */\n    skip(n = 1) {\n        this.offset += n;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes backward.\n     * @param n - Number of bytes to move back.\n     */\n    back(n = 1) {\n        this.offset -= n;\n        return this;\n    }\n    /**\n     * Move the pointer to the given offset.\n     * @param offset\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n    /**\n     * Move the pointer back to the last pointer offset set by mark.\n     * @see {@link IOBuffer#mark}\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n    /**\n     * Push the current pointer offset to the mark stack.\n     * @see {@link IOBuffer#popMark}\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current\n     * pointer offset to the popped value.\n     * @see {@link IOBuffer#pushMark}\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) {\n            throw new Error('Mark stack empty');\n        }\n        this.seek(offset);\n        return this;\n    }\n    /**\n     * Move the pointer offset back to 0.\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at\n     * the current pointer offset.\n     * If the buffer's memory is insufficient, this method will create a new\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\n     * @param byteLength\n     */\n    ensureAvailable(byteLength = 1) {\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\n     * Moves pointer forward by one byte.\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n    /**\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n    /**\n     * Alias for {@link IOBuffer#readUint8}.\n     */\n    readByte() {\n        return this.readUint8();\n    }\n    /**\n     * Read `n` bytes and move pointer forward by `n` bytes.\n     */\n    readBytes(n = 1) {\n        return this.readArray(n, 'uint8');\n    }\n    /**\n     * Creates an array of corresponding to the type `type` and size `size`.\n     * For example type `uint8` will create a `Uint8Array`.\n     * @param size - size of the resulting array\n     * @param type - number type of elements to read\n     */\n    readArray(size, type) {\n        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\n        const offset = this.byteOffset + this.offset;\n        const slice = this.buffer.slice(offset, offset + bytes);\n        if (this.littleEndian === hostBigEndian &&\n            type !== 'uint8' &&\n            type !== 'int8') {\n            const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\n            slice.reverse();\n            const returnArray = new typedArrays[type](slice.buffer);\n            this.offset += bytes;\n            returnArray.reverse();\n            return returnArray;\n        }\n        const returnArray = new typedArrays[type](slice);\n        this.offset += bytes;\n        return returnArray;\n    }\n    /**\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n     */\n    readInt16() {\n        const value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n     */\n    readUint16() {\n        const value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n     */\n    readInt32() {\n        const value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n     */\n    readUint32() {\n        const value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\n     */\n    readFloat32() {\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\n     */\n    readFloat64() {\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\n     */\n    readBigInt64() {\n        const value = this._data.getBigInt64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\n     */\n    readBigUint64() {\n        const value = this._data.getBigUint64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n     */\n    readChar() {\n        return String.fromCharCode(this.readInt8());\n    }\n    /**\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n     */\n    readChars(n = 1) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += this.readChar();\n        }\n        return result;\n    }\n    /**\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n     * forward by `n` bytes.\n     */\n    readUtf8(n = 1) {\n        return decode(this.readBytes(n));\n    }\n    /**\n     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\n     * forward by `n` bytes.\n     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\n     */\n    decodeText(n = 1, encoding = 'utf-8') {\n        return decode(this.readBytes(n), encoding);\n    }\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n     * forward by 1 byte.\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n     * byte.\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * An alias for {@link IOBuffer#writeUint8}.\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n    /**\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\n     * `bytes.length` bytes.\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        for (let i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\n     * bytes.\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n     * bytes.\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\n     * bytes.\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n     * bytes.\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\n     * bytes.\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\n     * bytes.\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit signed bigint and move pointer forward by 8\n     * bytes.\n     */\n    writeBigInt64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigInt64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\n     * bytes.\n     */\n    writeBigUint64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigUint64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n     * and move pointer forward by 1 byte.\n     */\n    writeChar(str) {\n        return this.writeUint8(str.charCodeAt(0));\n    }\n    /**\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n     * and move pointer forward by `str.length` bytes.\n     */\n    writeChars(str) {\n        for (let i = 0; i < str.length; i++) {\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n    /**\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\n     * forward according to the encoded length.\n     */\n    writeUtf8(str) {\n        return this.writeBytes(encode(str));\n    }\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n    }\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this.lastWrittenByte) {\n            this.lastWrittenByte = this.offset;\n        }\n    }\n}\n//# sourceMappingURL=IOBuffer.js.map","\"use strict\";\n/*\n * Copyright 2017 Sam Thorogood. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function (scope) {\n    'use strict';\n    // fail early\n    if (scope['TextEncoder'] && scope['TextDecoder']) {\n        return false;\n    }\n    /**\n     * @constructor\n     * @param {string=} utfLabel\n     */\n    function FastTextEncoder(utfLabel = 'utf-8') {\n        if (utfLabel !== 'utf-8') {\n            throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);\n        }\n    }\n    Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\n        value: 'utf-8',\n    });\n    /**\n     * @param {string} string\n     * @param {{stream: boolean}=} options\n     * @return {!Uint8Array}\n     */\n    FastTextEncoder.prototype.encode = function (string, options = { stream: false }) {\n        if (options.stream) {\n            throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\n        }\n        let pos = 0;\n        const len = string.length;\n        const out = [];\n        let at = 0; // output position\n        let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n        let target = new Uint8Array((tlen >> 3) << 3); // ... but at 8 byte offset\n        while (pos < len) {\n            let value = string.charCodeAt(pos++);\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < len) {\n                    const extra = string.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n                if (value >= 0xd800 && value <= 0xdbff) {\n                    continue; // drop lone surrogate\n                }\n            }\n            // expand the buffer if we couldn't write 4 bytes\n            if (at + 4 > target.length) {\n                tlen += 8; // minimum extra\n                tlen *= 1.0 + (pos / string.length) * 2; // take 2x the remaining\n                tlen = (tlen >> 3) << 3; // 8 byte offset\n                const update = new Uint8Array(tlen);\n                update.set(target);\n                target = update;\n            }\n            if ((value & 0xffffff80) === 0) {\n                // 1-byte\n                target[at++] = value; // ASCII\n                continue;\n            }\n            else if ((value & 0xfffff800) === 0) {\n                // 2-byte\n                target[at++] = ((value >> 6) & 0x1f) | 0xc0;\n            }\n            else if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                target[at++] = ((value >> 12) & 0x0f) | 0xe0;\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else if ((value & 0xffe00000) === 0) {\n                // 4-byte\n                target[at++] = ((value >> 18) & 0x07) | 0xf0;\n                target[at++] = ((value >> 12) & 0x3f) | 0x80;\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // FIXME: do we care\n                continue;\n            }\n            target[at++] = (value & 0x3f) | 0x80;\n        }\n        return target.slice(0, at);\n    };\n    /**\n     * @constructor\n     * @param {string=} utfLabel\n     * @param {{fatal: boolean}=} options\n     */\n    function FastTextDecoder(utfLabel = 'utf-8', options = { fatal: false }) {\n        if (utfLabel !== 'utf-8') {\n            throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);\n        }\n        if (options.fatal) {\n            throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);\n        }\n    }\n    Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\n        value: 'utf-8',\n    });\n    Object.defineProperty(FastTextDecoder.prototype, 'fatal', { value: false });\n    Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\n        value: false,\n    });\n    /**\n     * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\n     * @param {{stream: boolean}=} options\n     */\n    FastTextDecoder.prototype.decode = function (buffer, options = { stream: false }) {\n        if (options['stream']) {\n            throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\n        }\n        const bytes = new Uint8Array(buffer);\n        let pos = 0;\n        const len = bytes.length;\n        const out = [];\n        while (pos < len) {\n            const byte1 = bytes[pos++];\n            if (byte1 === 0) {\n                break; // NULL\n            }\n            if ((byte1 & 0x80) === 0) {\n                // 1-byte\n                out.push(byte1);\n            }\n            else if ((byte1 & 0xe0) === 0xc0) {\n                // 2-byte\n                const byte2 = bytes[pos++] & 0x3f;\n                out.push(((byte1 & 0x1f) << 6) | byte2);\n            }\n            else if ((byte1 & 0xf0) === 0xe0) {\n                const byte2 = bytes[pos++] & 0x3f;\n                const byte3 = bytes[pos++] & 0x3f;\n                out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n            }\n            else if ((byte1 & 0xf8) === 0xf0) {\n                const byte2 = bytes[pos++] & 0x3f;\n                const byte3 = bytes[pos++] & 0x3f;\n                const byte4 = bytes[pos++] & 0x3f;\n                // this can be > 0xffff, so possibly generate surrogates\n                let codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n                if (codepoint > 0xffff) {\n                    // codepoint &= ~0x10000;\n                    codepoint -= 0x10000;\n                    out.push(((codepoint >>> 10) & 0x3ff) | 0xd800);\n                    codepoint = 0xdc00 | (codepoint & 0x3ff);\n                }\n                out.push(codepoint);\n            }\n            else {\n                // FIXME: we're ignoring this\n            }\n        }\n        return String.fromCharCode.apply(null, out);\n    };\n    scope['TextEncoder'] = FastTextEncoder;\n    scope['TextDecoder'] = FastTextDecoder;\n})(typeof window !== 'undefined'\n    ? window\n    : typeof self !== 'undefined'\n        ? self\n        : this);\n//# sourceMappingURL=text-encoding-polyfill.js.map"],"names":["decode","bytes","encoding","TextDecoder","encoder","TextEncoder","hostBigEndian","array","Uint8Array","Uint32Array","buffer","typedArrays","int8","globalThis","Int8Array","uint8","int16","Int16Array","uint16","Uint16Array","int32","Int32Array","uint32","uint64","BigUint64Array","int64","BigInt64Array","float32","Float32Array","float64","Float64Array","IOBuffer","constructor","data","options","dataIsGiven","ArrayBuffer","this","lastWrittenByte","byteLength","offset","dvOffset","isView","byteOffset","length","littleEndian","_data","DataView","_mark","_marks","available","isLittleEndian","setLittleEndian","isBigEndian","setBigEndian","skip","n","back","seek","mark","reset","pushMark","push","popMark","pop","undefined","Error","rewind","ensureAvailable","newLength","newArray","set","readBoolean","readUint8","readInt8","getInt8","getUint8","readByte","readBytes","readArray","size","type","BYTES_PER_ELEMENT","slice","reverse","returnArray","readInt16","value","getInt16","readUint16","getUint16","readInt32","getInt32","readUint32","getUint32","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readChar","String","fromCharCode","readChars","result","i","readUtf8","decodeText","writeBoolean","writeUint8","writeInt8","setInt8","_updateLastWrittenByte","setUint8","writeByte","writeBytes","writeInt16","setInt16","writeUint16","setUint16","writeInt32","setInt32","writeUint32","setUint32","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","writeChar","str","charCodeAt","writeChars","writeUtf8","encode","toArray","scope","FastTextEncoder","utfLabel","RangeError","FastTextDecoder","fatal","Object","defineProperty","prototype","string","stream","pos","len","at","tlen","Math","max","target","extra","update","out","byte1","byte2","byte3","codepoint","apply","window","self"],"sourceRoot":""}